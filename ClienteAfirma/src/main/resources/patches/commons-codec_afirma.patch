diff -Nru old\org\apache\commons\codec\binary\Base64.java new\org\apache\commons\codec\binary\Base64.java
--- old\org\apache\commons\codec\binary\Base64.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\binary\Base64.java	Tue Jun 22 08:40:25 2010
@@ -19,8 +19,6 @@
 
 import java.math.BigInteger;
 
-import org.apache.commons.codec.BinaryDecoder;
-import org.apache.commons.codec.BinaryEncoder;
 import org.apache.commons.codec.DecoderException;
 import org.apache.commons.codec.EncoderException;
 
@@ -50,7 +48,7 @@
  * @since 1.0
  * @version $Id: Base64.java 801706 2009-08-06 16:27:06Z niallp $
  */
-public class Base64 implements BinaryEncoder, BinaryDecoder {
+public class Base64 {
     private static final int DEFAULT_BUFFER_RESIZE_FACTOR = 2;
 
     private static final int DEFAULT_BUFFER_SIZE = 8192;
@@ -946,7 +944,7 @@
             System.arraycopy(buf, 0, smallerBuf, 0, pos);
             buf = smallerBuf;
         }
-        return buf;        
+        return buf;
     }
 
     /**
diff -Nru old\org\apache\commons\codec\binary\Base64InputStream.java new\org\apache\commons\codec\binary\Base64InputStream.java
--- old\org\apache\commons\codec\binary\Base64InputStream.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\binary\Base64InputStream.java	Thu Jan 01 01:00:00 1970
@@ -1,174 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-/**
- * Provides Base64 encoding and decoding in a streaming fashion (unlimited size). When encoding the default lineLength
- * is 76 characters and the default lineEnding is CRLF, but these can be overridden by using the appropriate
- * constructor.
- * <p>
- * The default behaviour of the Base64InputStream is to DECODE, whereas the default behaviour of the Base64OutputStream
- * is to ENCODE, but this behaviour can be overridden by using a different constructor.
- * </p>
- * <p>
- * This class implements section <cite>6.8. Base64 Content-Transfer-Encoding</cite> from RFC 2045 <cite>Multipurpose
- * Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</cite> by Freed and Borenstein.
- * </p>
- * <p>
- * Since this class operates directly on byte streams, and not character streams, it is hard-coded to only encode/decode
- * character encodings which are compatible with the lower 127 ASCII chart (ISO-8859-1, Windows-1252, UTF-8, etc).
- * </p>
- * 
- * @author Apache Software Foundation 
- * @version $Id: Base64InputStream.java 799805 2009-08-01 04:33:05Z ggregory $
- * @see <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</a>
- * @since 1.4
- */
-public class Base64InputStream extends FilterInputStream {
-
-    private final boolean doEncode;
-
-    private final Base64 base64;
-
-    private final byte[] singleByte = new byte[1];
-
-    /**
-     * Creates a Base64InputStream such that all data read is Base64-decoded from the original provided InputStream.
-     * 
-     * @param in
-     *            InputStream to wrap.
-     */
-    public Base64InputStream(InputStream in) {
-        this(in, false);
-    }
-
-    /**
-     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
-     * provided InputStream.
-     * 
-     * @param in
-     *            InputStream to wrap.
-     * @param doEncode
-     *            true if we should encode all data read from us, false if we should decode.
-     */
-    public Base64InputStream(InputStream in, boolean doEncode) {
-        super(in);
-        this.doEncode = doEncode;
-        this.base64 = new Base64();
-    }
-
-    /**
-     * Creates a Base64InputStream such that all data read is either Base64-encoded or Base64-decoded from the original
-     * provided InputStream.
-     * 
-     * @param in
-     *            InputStream to wrap.
-     * @param doEncode
-     *            true if we should encode all data read from us, false if we should decode.
-     * @param lineLength
-     *            If doEncode is true, each line of encoded data will contain lineLength characters (rounded down to
-     *            nearest multiple of 4). If lineLength <=0, the encoded data is not divided into lines. If doEncode is
-     *            false, lineLength is ignored.
-     * @param lineSeparator
-     *            If doEncode is true, each line of encoded data will be terminated with this byte sequence (e.g. \r\n).
-     *            If lineLength <= 0, the lineSeparator is not used. If doEncode is false lineSeparator is ignored.
-     */
-    public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {
-        super(in);
-        this.doEncode = doEncode;
-        this.base64 = new Base64(lineLength, lineSeparator);
-    }
-
-    /**
-     * Reads one <code>byte</code> from this input stream.
-     * 
-     * @return the byte as an integer in the range 0 to 255. Returns -1 if EOF has been reached.
-     * @throws IOException
-     *             if an I/O error occurs.
-     */
-    public int read() throws IOException {
-        int r = read(singleByte, 0, 1);
-        while (r == 0) {
-            r = read(singleByte, 0, 1);
-        }
-        if (r > 0) {
-            return singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];
-        }
-        return -1;
-    }
-
-    /**
-     * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
-     * from this InputStream.
-     * 
-     * @param b
-     *            destination byte array
-     * @param offset
-     *            where to start writing the bytes
-     * @param len
-     *            maximum number of bytes to read
-     * 
-     * @return number of bytes read
-     * @throws IOException
-     *             if an I/O error occurs.
-     * @throws NullPointerException
-     *             if the byte array parameter is null
-     * @throws IndexOutOfBoundsException
-     *             if offset, len or buffer size are invalid
-     */
-    public int read(byte b[], int offset, int len) throws IOException {
-        if (b == null) {
-            throw new NullPointerException();
-        } else if (offset < 0 || len < 0) {
-            throw new IndexOutOfBoundsException();
-        } else if (offset > b.length || offset + len > b.length) {
-            throw new IndexOutOfBoundsException();
-        } else if (len == 0) {
-            return 0;
-        } else {
-            if (!base64.hasData()) {
-                byte[] buf = new byte[doEncode ? 4096 : 8192];
-                int c = in.read(buf);
-                // A little optimization to avoid System.arraycopy()
-                // when possible.
-                if (c > 0 && b.length == len) {
-                    base64.setInitialBuffer(b, offset, len);
-                }
-                if (doEncode) {
-                    base64.encode(buf, 0, c);
-                } else {
-                    base64.decode(buf, 0, c);
-                }
-            }
-            return base64.readResults(b, offset, len);
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     * 
-     * @return false
-     */
-    public boolean markSupported() {
-        return false; // not an easy job to support marks
-    }
-}
diff -Nru old\org\apache\commons\codec\binary\BinaryCodec.java new\org\apache\commons\codec\binary\BinaryCodec.java
--- old\org\apache\commons\codec\binary\BinaryCodec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\binary\BinaryCodec.java	Thu Jan 01 01:00:00 1970
@@ -1,296 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import org.apache.commons.codec.BinaryDecoder;
-import org.apache.commons.codec.BinaryEncoder;
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-
-/**
- * Translates between byte arrays and strings of "0"s and "1"s.
- * 
- * TODO: may want to add more bit vector functions like and/or/xor/nand 
- * TODO: also might be good to generate boolean[] from byte[] et. cetera.
- * 
- * @author Apache Software Foundation
- * @since 1.3
- * @version $Id: BinaryCodec.java 798433 2009-07-28 07:53:10Z ggregory $
- */
-public class BinaryCodec implements BinaryDecoder, BinaryEncoder {
-    /*
-     * tried to avoid using ArrayUtils to minimize dependencies while using these empty arrays - dep is just not worth
-     * it.
-     */
-    /** Empty char array. */
-    private static final char[] EMPTY_CHAR_ARRAY = new char[0];
-
-    /** Empty byte array. */
-    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];
-
-    /** Mask for bit 0 of a byte. */
-    private static final int BIT_0 = 1;
-
-    /** Mask for bit 1 of a byte. */
-    private static final int BIT_1 = 0x02;
-
-    /** Mask for bit 2 of a byte. */
-    private static final int BIT_2 = 0x04;
-
-    /** Mask for bit 3 of a byte. */
-    private static final int BIT_3 = 0x08;
-
-    /** Mask for bit 4 of a byte. */
-    private static final int BIT_4 = 0x10;
-
-    /** Mask for bit 5 of a byte. */
-    private static final int BIT_5 = 0x20;
-
-    /** Mask for bit 6 of a byte. */
-    private static final int BIT_6 = 0x40;
-
-    /** Mask for bit 7 of a byte. */
-    private static final int BIT_7 = 0x80;
-
-    private static final int[] BITS = {BIT_0, BIT_1, BIT_2, BIT_3, BIT_4, BIT_5, BIT_6, BIT_7};
-
-    /**
-     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.
-     * 
-     * @param raw
-     *                  the raw binary data to convert
-     * @return 0 and 1 ASCII character bytes one for each bit of the argument
-     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])
-     */
-    public byte[] encode(byte[] raw) {
-        return toAsciiBytes(raw);
-    }
-
-    /**
-     * Converts an array of raw binary data into an array of ASCII 0 and 1 chars.
-     * 
-     * @param raw
-     *                  the raw binary data to convert
-     * @return 0 and 1 ASCII character chars one for each bit of the argument
-     * @throws EncoderException
-     *                  if the argument is not a byte[]
-     * @see org.apache.commons.codec.Encoder#encode(Object)
-     */
-    public Object encode(Object raw) throws EncoderException {
-        if (!(raw instanceof byte[])) {
-            throw new EncoderException("argument not a byte array");
-        }
-        return toAsciiChars((byte[]) raw);
-    }
-
-    /**
-     * Decodes a byte array where each byte represents an ASCII '0' or '1'.
-     * 
-     * @param ascii
-     *                  each byte represents an ASCII '0' or '1'
-     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
-     * @throws DecoderException
-     *                  if argument is not a byte[], char[] or String
-     * @see org.apache.commons.codec.Decoder#decode(Object)
-     */
-    public Object decode(Object ascii) throws DecoderException {
-        if (ascii == null) {
-            return EMPTY_BYTE_ARRAY;
-        }
-        if (ascii instanceof byte[]) {
-            return fromAscii((byte[]) ascii);
-        }
-        if (ascii instanceof char[]) {
-            return fromAscii((char[]) ascii);
-        }
-        if (ascii instanceof String) {
-            return fromAscii(((String) ascii).toCharArray());
-        }
-        throw new DecoderException("argument not a byte array");
-    }
-
-    /**
-     * Decodes a byte array where each byte represents an ASCII '0' or '1'.
-     * 
-     * @param ascii
-     *                  each byte represents an ASCII '0' or '1'
-     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
-     * @see org.apache.commons.codec.Decoder#decode(Object)
-     */
-    public byte[] decode(byte[] ascii) {
-        return fromAscii(ascii);
-    }
-
-    /**
-     * Decodes a String where each char of the String represents an ASCII '0' or '1'.
-     * 
-     * @param ascii
-     *                  String of '0' and '1' characters
-     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
-     * @see org.apache.commons.codec.Decoder#decode(Object)
-     */
-    public byte[] toByteArray(String ascii) {
-        if (ascii == null) {
-            return EMPTY_BYTE_ARRAY;
-        }
-        return fromAscii(ascii.toCharArray());
-    }
-
-    // ------------------------------------------------------------------------
-    //
-    // static codec operations
-    //
-    // ------------------------------------------------------------------------
-    /**
-     * Decodes a char array where each char represents an ASCII '0' or '1'.
-     * 
-     * @param ascii
-     *                  each char represents an ASCII '0' or '1'
-     * @return the raw encoded binary where each bit corresponds to a char in the char array argument
-     */
-    public static byte[] fromAscii(char[] ascii) {
-        if (ascii == null || ascii.length == 0) {
-            return EMPTY_BYTE_ARRAY;
-        }
-        // get length/8 times bytes with 3 bit shifts to the right of the length
-        byte[] l_raw = new byte[ascii.length >> 3];
-        /*
-         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
-         * loop.
-         */
-        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {
-            for (int bits = 0; bits < BITS.length; ++bits) {
-                if (ascii[jj - bits] == '1') {
-                    l_raw[ii] |= BITS[bits];
-                }
-            }
-        }
-        return l_raw;
-    }
-
-    /**
-     * Decodes a byte array where each byte represents an ASCII '0' or '1'.
-     * 
-     * @param ascii
-     *                  each byte represents an ASCII '0' or '1'
-     * @return the raw encoded binary where each bit corresponds to a byte in the byte array argument
-     */
-    public static byte[] fromAscii(byte[] ascii) {
-        if (isEmpty(ascii)) {
-            return EMPTY_BYTE_ARRAY;
-        }
-        // get length/8 times bytes with 3 bit shifts to the right of the length
-        byte[] l_raw = new byte[ascii.length >> 3];
-        /*
-         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
-         * loop.
-         */
-        for (int ii = 0, jj = ascii.length - 1; ii < l_raw.length; ii++, jj -= 8) {
-            for (int bits = 0; bits < BITS.length; ++bits) {
-                if (ascii[jj - bits] == '1') {
-                    l_raw[ii] |= BITS[bits];
-                }
-            }
-        }
-        return l_raw;
-    }
-
-    /**
-     * Returns <code>true</code> if the given array is <code>null</code> or empty (size 0.)
-     * 
-     * @param array
-     *            the source array
-     * @return <code>true</code> if the given array is <code>null</code> or empty (size 0.)
-     */
-    private static boolean isEmpty(byte[] array) {
-        return array == null || array.length == 0;
-    }
-
-    /**
-     * Converts an array of raw binary data into an array of ASCII 0 and 1 character bytes - each byte is a truncated
-     * char.
-     * 
-     * @param raw
-     *                  the raw binary data to convert
-     * @return an array of 0 and 1 character bytes for each bit of the argument
-     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])
-     */
-    public static byte[] toAsciiBytes(byte[] raw) {
-        if (isEmpty(raw)) {
-            return EMPTY_BYTE_ARRAY;
-        }
-        // get 8 times the bytes with 3 bit shifts to the left of the length
-        byte[] l_ascii = new byte[raw.length << 3];
-        /*
-         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
-         * loop.
-         */
-        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {
-            for (int bits = 0; bits < BITS.length; ++bits) {
-                if ((raw[ii] & BITS[bits]) == 0) {
-                    l_ascii[jj - bits] = '0';
-                } else {
-                    l_ascii[jj - bits] = '1';
-                }
-            }
-        }
-        return l_ascii;
-    }
-
-    /**
-     * Converts an array of raw binary data into an array of ASCII 0 and 1 characters.
-     * 
-     * @param raw
-     *                  the raw binary data to convert
-     * @return an array of 0 and 1 characters for each bit of the argument
-     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])
-     */
-    public static char[] toAsciiChars(byte[] raw) {
-        if (isEmpty(raw)) {
-            return EMPTY_CHAR_ARRAY;
-        }
-        // get 8 times the bytes with 3 bit shifts to the left of the length
-        char[] l_ascii = new char[raw.length << 3];
-        /*
-         * We decr index jj by 8 as we go along to not recompute indices using multiplication every time inside the
-         * loop.
-         */
-        for (int ii = 0, jj = l_ascii.length - 1; ii < raw.length; ii++, jj -= 8) {
-            for (int bits = 0; bits < BITS.length; ++bits) {
-                if ((raw[ii] & BITS[bits]) == 0) {
-                    l_ascii[jj - bits] = '0';
-                } else {
-                    l_ascii[jj - bits] = '1';
-                }
-            }
-        }
-        return l_ascii;
-    }
-
-    /**
-     * Converts an array of raw binary data into a String of ASCII 0 and 1 characters.
-     * 
-     * @param raw
-     *                  the raw binary data to convert
-     * @return a String of 0 and 1 characters representing the binary data
-     * @see org.apache.commons.codec.BinaryEncoder#encode(byte[])
-     */
-    public static String toAsciiString(byte[] raw) {
-        return new String(toAsciiChars(raw));
-    }
-}
diff -Nru old\org\apache\commons\codec\binary\Hex.java new\org\apache\commons\codec\binary\Hex.java
--- old\org\apache\commons\codec\binary\Hex.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\binary\Hex.java	Thu Jan 01 01:00:00 1970
@@ -1,299 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.binary;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.commons.codec.BinaryDecoder;
-import org.apache.commons.codec.BinaryEncoder;
-import org.apache.commons.codec.CharEncoding;
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-
-/**
- * Hex encoder and decoder. The charset used for certain operation can be set, the default is set in
- * {@link #DEFAULT_CHARSET_NAME}
- * 
- * @since 1.1
- * @author Apache Software Foundation
- * @version $Id: Hex.java 801639 2009-08-06 13:15:10Z niallp $
- */
-public class Hex implements BinaryEncoder, BinaryDecoder {
-
-    /**
-     * Default charset name is {@link CharEncoding#UTF_8}
-     */
-    public static final String DEFAULT_CHARSET_NAME = CharEncoding.UTF_8;
-
-    /**
-     * Used to build output as Hex
-     */
-    private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
-
-    /**
-     * Used to build output as Hex
-     */
-    private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
-
-    /**
-     * Converts an array of characters representing hexadecimal values into an array of bytes of those same values. The
-     * returned array will be half the length of the passed array, as it takes two characters to represent any given
-     * byte. An exception is thrown if the passed char array has an odd number of elements.
-     * 
-     * @param data
-     *            An array of characters containing hexadecimal digits
-     * @return A byte array containing binary data decoded from the supplied char array.
-     * @throws DecoderException
-     *             Thrown if an odd number or illegal of characters is supplied
-     */
-    public static byte[] decodeHex(char[] data) throws DecoderException {
-
-        int len = data.length;
-
-        if ((len & 0x01) != 0) {
-            throw new DecoderException("Odd number of characters.");
-        }
-
-        byte[] out = new byte[len >> 1];
-
-        // two characters form the hex value.
-        for (int i = 0, j = 0; j < len; i++) {
-            int f = toDigit(data[j], j) << 4;
-            j++;
-            f = f | toDigit(data[j], j);
-            j++;
-            out[i] = (byte) (f & 0xFF);
-        }
-
-        return out;
-    }
-
-    /**
-     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
-     * The returned array will be double the length of the passed array, as it takes two characters to represent any
-     * given byte.
-     * 
-     * @param data
-     *            a byte[] to convert to Hex characters
-     * @return A char[] containing hexadecimal characters
-     */
-    public static char[] encodeHex(byte[] data) {
-        return encodeHex(data, true);
-    }
-
-    /**
-     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
-     * The returned array will be double the length of the passed array, as it takes two characters to represent any
-     * given byte.
-     * 
-     * @param data
-     *            a byte[] to convert to Hex characters
-     * @param toLowerCase
-     *            <code>true</code> converts to lowercase, <code>false</code> to uppercase
-     * @return A char[] containing hexadecimal characters
-     * @since 1.4
-     */
-    public static char[] encodeHex(byte[] data, boolean toLowerCase) {
-        return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);
-    }
-
-    /**
-     * Converts an array of bytes into an array of characters representing the hexadecimal values of each byte in order.
-     * The returned array will be double the length of the passed array, as it takes two characters to represent any
-     * given byte.
-     * 
-     * @param data
-     *            a byte[] to convert to Hex characters
-     * @param toDigits
-     *            the output alphabet
-     * @return A char[] containing hexadecimal characters
-     * @since 1.4
-     */
-    protected static char[] encodeHex(byte[] data, char[] toDigits) {
-        int l = data.length;
-        char[] out = new char[l << 1];
-        // two characters form the hex value.
-        for (int i = 0, j = 0; i < l; i++) {
-            out[j++] = toDigits[(0xF0 & data[i]) >>> 4];
-            out[j++] = toDigits[0x0F & data[i]];
-        }
-        return out;
-    }
-
-    /**
-     * Converts an array of bytes into a String representing the hexadecimal values of each byte in order. The returned
-     * String will be double the length of the passed array, as it takes two characters to represent any given byte.
-     * 
-     * @param data
-     *            a byte[] to convert to Hex characters
-     * @return A String containing hexadecimal characters
-     * @since 1.4
-     */
-    public static String encodeHexString(byte[] data) {
-        return new String(encodeHex(data));
-    }
-
-    /**
-     * Converts a hexadecimal character to an integer.
-     * 
-     * @param ch
-     *            A character to convert to an integer digit
-     * @param index
-     *            The index of the character in the source
-     * @return An integer
-     * @throws DecoderException
-     *             Thrown if ch is an illegal hex character
-     */
-    protected static int toDigit(char ch, int index) throws DecoderException {
-        int digit = Character.digit(ch, 16);
-        if (digit == -1) {
-            throw new DecoderException("Illegal hexadecimal charcter " + ch + " at index " + index);
-        }
-        return digit;
-    }
-
-    private final String charsetName;
-
-    /**
-     * Creates a new codec with the default charset name {@link #DEFAULT_CHARSET_NAME}
-     */
-    public Hex() {
-        // use default encoding
-        this.charsetName = DEFAULT_CHARSET_NAME;
-    }
-
-    /**
-     * Creates a new codec with the given charset name.
-     * 
-     * @param csName
-     *            the charset name.
-     * @since 1.4
-     */
-    public Hex(String csName) {
-        this.charsetName = csName;
-    }
-
-    /**
-     * Converts an array of character bytes representing hexadecimal values into an array of bytes of those same values.
-     * The returned array will be half the length of the passed array, as it takes two characters to represent any given
-     * byte. An exception is thrown if the passed char array has an odd number of elements.
-     * 
-     * @param array
-     *            An array of character bytes containing hexadecimal digits
-     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
-     * @throws DecoderException
-     *             Thrown if an odd number of characters is supplied to this function
-     * @see #decodeHex(char[])
-     */
-    public byte[] decode(byte[] array) throws DecoderException {
-        try {
-            return decodeHex(new String(array, getCharsetName()).toCharArray());
-        } catch (UnsupportedEncodingException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Converts a String or an array of character bytes representing hexadecimal values into an array of bytes of those
-     * same values. The returned array will be half the length of the passed String or array, as it takes two characters
-     * to represent any given byte. An exception is thrown if the passed char array has an odd number of elements.
-     * 
-     * @param object
-     *            A String or, an array of character bytes containing hexadecimal digits
-     * @return A byte array containing binary data decoded from the supplied byte array (representing characters).
-     * @throws DecoderException
-     *             Thrown if an odd number of characters is supplied to this function or the object is not a String or
-     *             char[]
-     * @see #decodeHex(char[])
-     */
-    public Object decode(Object object) throws DecoderException {
-        try {
-            char[] charArray = object instanceof String ? ((String) object).toCharArray() : (char[]) object;
-            return decodeHex(charArray);
-        } catch (ClassCastException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Converts an array of bytes into an array of bytes for the characters representing the hexadecimal values of each
-     * byte in order. The returned array will be double the length of the passed array, as it takes two characters to
-     * represent any given byte.
-     * <p>
-     * The conversion from hexadecimal characters to the returned bytes is performed with the charset named by
-     * {@link #getCharsetName()}.
-     * </p>
-     * 
-     * @param array
-     *            a byte[] to convert to Hex characters
-     * @return A byte[] containing the bytes of the hexadecimal characters
-     * @throws IllegalStateException
-     *             if the charsetName is invalid. This API throws {@link IllegalStateException} instead of
-     *             {@link UnsupportedEncodingException} for backward compatibility.
-     * @see #encodeHex(byte[])
-     */
-    public byte[] encode(byte[] array) {
-        return StringUtils.getBytesUnchecked(encodeHexString(array), getCharsetName());
-    }
-
-    /**
-     * Converts a String or an array of bytes into an array of characters representing the hexadecimal values of each
-     * byte in order. The returned array will be double the length of the passed String or array, as it takes two
-     * characters to represent any given byte.
-     * <p>
-     * The conversion from hexadecimal characters to bytes to be encoded to performed with the charset named by
-     * {@link #getCharsetName()}.
-     * </p>
-     * 
-     * @param object
-     *            a String, or byte[] to convert to Hex characters
-     * @return A char[] containing hexadecimal characters
-     * @throws EncoderException
-     *             Thrown if the given object is not a String or byte[]
-     * @see #encodeHex(byte[])
-     */
-    public Object encode(Object object) throws EncoderException {
-        try {
-            byte[] byteArray = object instanceof String ? ((String) object).getBytes(getCharsetName()) : (byte[]) object;
-            return encodeHex(byteArray);
-        } catch (ClassCastException e) {
-            throw new EncoderException(e.getMessage(), e);
-        } catch (UnsupportedEncodingException e) {
-            throw new EncoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Gets the charset name.
-     * 
-     * @return the charset name.
-     * @since 1.4
-     */
-    public String getCharsetName() {
-        return this.charsetName;
-    }
-
-    /**
-     * Returns a string representation of the object, which includes the charset name.
-     * 
-     * @return a string representation of the object.
-     */
-    public String toString() {
-        return super.toString() + "[charsetName=" + this.charsetName + "]";
-    }
-}
diff -Nru old\org\apache\commons\codec\binary\package.html new\org\apache\commons\codec\binary\package.html
--- old\org\apache\commons\codec\binary\package.html	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\binary\package.html	Thu Jan 01 01:00:00 1970
@@ -1,21 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<html>
- <body>
-  Base64, Binary, and Hexadecimal String encoding and decoding.
- </body>
-</html>
diff -Nru old\org\apache\commons\codec\BinaryDecoder.java new\org\apache\commons\codec\BinaryDecoder.java
--- old\org\apache\commons\codec\BinaryDecoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\BinaryDecoder.java	Thu Jan 01 01:00:00 1970
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * Defines common decoding methods for byte array decoders.
- *
- * @author Apache Software Foundation
- * @version $Id: BinaryDecoder.java 651573 2008-04-25 11:11:21Z niallp $
- */
-public interface BinaryDecoder extends Decoder {
-
-    /**
-     * Decodes a byte array and returns the results as a byte array. 
-     *
-     * @param pArray A byte array which has been encoded with the
-     *      appropriate encoder
-     * 
-     * @return a byte array that contains decoded content
-     * 
-     * @throws DecoderException A decoder exception is thrown
-     *          if a Decoder encounters a failure condition during
-     *          the decode process.
-     */
-    byte[] decode(byte[] pArray) throws DecoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\BinaryEncoder.java new\org\apache\commons\codec\BinaryEncoder.java
--- old\org\apache\commons\codec\BinaryEncoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\BinaryEncoder.java	Thu Jan 01 01:00:00 1970
@@ -1,42 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * Defines common encoding methods for byte array encoders.
- * 
- * @author Apache Software Foundation
- * @version $Id: BinaryEncoder.java 651573 2008-04-25 11:11:21Z niallp $
- */
-public interface BinaryEncoder extends Encoder {
-    
-    /**
-     * Encodes a byte array and return the encoded data
-     * as a byte array.
-     * 
-     * @param pArray Data to be encoded
-     *
-     * @return A byte array containing the encoded data
-     * 
-     * @throws EncoderException thrown if the Encoder
-     *      encounters a failure condition during the
-     *      encoding process.
-     */
-    byte[] encode(byte[] pArray) throws EncoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\Decoder.java new\org\apache\commons\codec\Decoder.java
--- old\org\apache\commons\codec\Decoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\Decoder.java	Thu Jan 01 01:00:00 1970
@@ -1,55 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * <p>Provides the highest level of abstraction for Decoders.
- * This is the sister interface of {@link Encoder}.  All
- * Decoders implement this common generic interface.</p>
- * 
- * <p>Allows a user to pass a generic Object to any Decoder 
- * implementation in the codec package.</p>
- * 
- * <p>One of the two interfaces at the center of the codec package.</p>
- * 
- * @author Apache Software Foundation
- * @version $Id: Decoder.java 797690 2009-07-24 23:28:35Z ggregory $
- */
-public interface Decoder {
-
-    /**
-     * Decodes an "encoded" Object and returns a "decoded"
-     * Object.  Note that the implementation of this
-     * interface will try to cast the Object parameter
-     * to the specific type expected by a particular Decoder
-     * implementation.  If a {@link ClassCastException} occurs
-     * this decode method will throw a DecoderException.
-     * 
-     * @param pObject an object to "decode"
-     * 
-     * @return a 'decoded" object
-     * 
-     * @throws DecoderException a decoder exception can
-     * be thrown for any number of reasons.  Some good
-     * candidates are that the parameter passed to this
-     * method is null, a param cannot be cast to the
-     * appropriate type for a specific encoder.
-     */
-    Object decode(Object pObject) throws DecoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\digest\DigestUtils.java new\org\apache\commons\codec\digest\DigestUtils.java
--- old\org\apache\commons\codec\digest\DigestUtils.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\digest\DigestUtils.java	Thu Jan 01 01:00:00 1970
@@ -1,582 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.digest;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.security.MessageDigest;
-import java.security.NoSuchAlgorithmException;
-
-import org.apache.commons.codec.binary.Hex;
-import org.apache.commons.codec.binary.StringUtils;
-
-/**
- * Operations to simplifiy common {@link java.security.MessageDigest} tasks. This class is thread safe.
- * 
- * @author Apache Software Foundation
- * @version $Id: DigestUtils.java 801391 2009-08-05 19:55:54Z ggregory $
- */
-public class DigestUtils {
-
-    private static final int STREAM_BUFFER_LENGTH = 1024;
-
-    /**
-     * Read through an InputStream and returns the digest for the data
-     * 
-     * @param digest
-     *            The MessageDigest to use (e.g. MD5)
-     * @param data
-     *            Data to digest
-     * @return MD5 digest
-     * @throws IOException
-     *             On error reading from the stream
-     */
-    private static byte[] digest(MessageDigest digest, InputStream data) throws IOException {
-        byte[] buffer = new byte[STREAM_BUFFER_LENGTH];
-        int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);
-
-        while (read > -1) {
-            digest.update(buffer, 0, read);
-            read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);
-        }
-
-        return digest.digest();
-    }
-
-    /**
-     * Calls {@link StringUtils#getBytesUtf8(String)}
-     * 
-     * @param string
-     *            the String to encode
-     * @return encoded bytes
-     */
-    private static byte[] getBytesUtf8(String data) {
-        return StringUtils.getBytesUtf8(data);
-    }
-
-    /**
-     * Returns a <code>MessageDigest</code> for the given <code>algorithm</code>.
-     * 
-     * @param algorithm
-     *            the name of the algorithm requested. See <a
-     *            href="http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA">Appendix A in the Java
-     *            Cryptography Architecture API Specification & Reference</a> for information about standard algorithm
-     *            names.
-     * @return An MD5 digest instance.
-     * @see MessageDigest#getInstance(String)
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    static MessageDigest getDigest(String algorithm) {
-        try {
-            return MessageDigest.getInstance(algorithm);
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e.getMessage());
-        }
-    }
-
-    /**
-     * Returns an MD5 MessageDigest.
-     * 
-     * @return An MD5 digest instance.
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    private static MessageDigest getMd5Digest() {
-        return getDigest("MD5");
-    }
-
-    /**
-     * Returns an SHA-256 digest.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @return An SHA-256 digest instance.
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    private static MessageDigest getSha256Digest() {
-        return getDigest("SHA-256");
-    }
-
-    /**
-     * Returns an SHA-384 digest.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @return An SHA-384 digest instance.
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    private static MessageDigest getSha384Digest() {
-        return getDigest("SHA-384");
-    }
-
-    /**
-     * Returns an SHA-512 digest.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @return An SHA-512 digest instance.
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    private static MessageDigest getSha512Digest() {
-        return getDigest("SHA-512");
-    }
-
-    /**
-     * Returns an SHA-1 digest.
-     * 
-     * @return An SHA-1 digest instance.
-     * @throws RuntimeException
-     *             when a {@link java.security.NoSuchAlgorithmException} is caught.
-     */
-    private static MessageDigest getShaDigest() {
-        return getDigest("SHA");
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest
-     */
-    public static byte[] md5(byte[] data) {
-        return getMd5Digest().digest(data);
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static byte[] md5(InputStream data) throws IOException {
-        return digest(getMd5Digest(), data);
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 16 element <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest
-     */
-    public static byte[] md5(String data) {
-        return md5(getBytesUtf8(data));
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 32 character hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest as a hex string
-     */
-    public static String md5Hex(byte[] data) {
-        return Hex.encodeHexString(md5(data));
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 32 character hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest as a hex string
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static String md5Hex(InputStream data) throws IOException {
-        return Hex.encodeHexString(md5(data));
-    }
-
-    /**
-     * Calculates the MD5 digest and returns the value as a 32 character hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return MD5 digest as a hex string
-     */
-    public static String md5Hex(String data) {
-        return Hex.encodeHexString(md5(data));
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest
-     */
-    public static byte[] sha(byte[] data) {
-        return getShaDigest().digest(data);
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static byte[] sha(InputStream data) throws IOException {
-        return digest(getShaDigest(), data);
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a <code>byte[]</code>.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest
-     */
-    public static byte[] sha(String data) {
-        return sha(getBytesUtf8(data));
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest
-     * @since 1.4
-     */
-    public static byte[] sha256(byte[] data) {
-        return getSha256Digest().digest(data);
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static byte[] sha256(InputStream data) throws IOException {
-        return digest(getSha256Digest(), data);
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest
-     * @since 1.4
-     */
-    public static byte[] sha256(String data) {
-        return sha256(getBytesUtf8(data));
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha256Hex(byte[] data) {
-        return Hex.encodeHexString(sha256(data));
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest as a hex string
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static String sha256Hex(InputStream data) throws IOException {
-        return Hex.encodeHexString(sha256(data));
-    }
-
-    /**
-     * Calculates the SHA-256 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-256 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha256Hex(String data) {
-        return Hex.encodeHexString(sha256(data));
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest
-     * @since 1.4
-     */
-    public static byte[] sha384(byte[] data) {
-        return getSha384Digest().digest(data);
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static byte[] sha384(InputStream data) throws IOException {
-        return digest(getSha384Digest(), data);
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest
-     * @since 1.4
-     */
-    public static byte[] sha384(String data) {
-        return sha384(getBytesUtf8(data));
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha384Hex(byte[] data) {
-        return Hex.encodeHexString(sha384(data));
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest as a hex string
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static String sha384Hex(InputStream data) throws IOException {
-        return Hex.encodeHexString(sha384(data));
-    }
-
-    /**
-     * Calculates the SHA-384 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-384 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha384Hex(String data) {
-        return Hex.encodeHexString(sha384(data));
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest
-     * @since 1.4
-     */
-    public static byte[] sha512(byte[] data) {
-        return getSha512Digest().digest(data);
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static byte[] sha512(InputStream data) throws IOException {
-        return digest(getSha512Digest(), data);
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a <code>byte[]</code>.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest
-     * @since 1.4
-     */
-    public static byte[] sha512(String data) {
-        return sha512(getBytesUtf8(data));
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha512Hex(byte[] data) {
-        return Hex.encodeHexString(sha512(data));
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest as a hex string
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static String sha512Hex(InputStream data) throws IOException {
-        return Hex.encodeHexString(sha512(data));
-    }
-
-    /**
-     * Calculates the SHA-512 digest and returns the value as a hex string.
-     * <p>
-     * Throws a <code>RuntimeException</code> on JRE versions prior to 1.4.0.
-     * </p>
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-512 digest as a hex string
-     * @since 1.4
-     */
-    public static String sha512Hex(String data) {
-        return Hex.encodeHexString(sha512(data));
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest as a hex string
-     */
-    public static String shaHex(byte[] data) {
-        return Hex.encodeHexString(sha(data));
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest as a hex string
-     * @throws IOException
-     *             On error reading from the stream
-     * @since 1.4
-     */
-    public static String shaHex(InputStream data) throws IOException {
-        return Hex.encodeHexString(sha(data));
-    }
-
-    /**
-     * Calculates the SHA-1 digest and returns the value as a hex string.
-     * 
-     * @param data
-     *            Data to digest
-     * @return SHA-1 digest as a hex string
-     */
-    public static String shaHex(String data) {
-        return Hex.encodeHexString(sha(data));
-    }
-}
diff -Nru old\org\apache\commons\codec\digest\package.html new\org\apache\commons\codec\digest\package.html
--- old\org\apache\commons\codec\digest\package.html	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\digest\package.html	Thu Jan 01 01:00:00 1970
@@ -1,21 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<html>
- <body>
-   Operations to simplifiy common <code>MessageDigest</code> tasks.
- </body>
-</html>
diff -Nru old\org\apache\commons\codec\Encoder.java new\org\apache\commons\codec\Encoder.java
--- old\org\apache\commons\codec\Encoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\Encoder.java	Thu Jan 01 01:00:00 1970
@@ -1,46 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * <p>Provides the highest level of abstraction for Encoders.
- * This is the sister interface of {@link Decoder}.  Every implementation of
- * Encoder provides this common generic interface whic allows a user to pass a 
- * generic Object to any Encoder implementation in the codec package.</p>
- *
- * @author Apache Software Foundation
- * @version $Id: Encoder.java 634915 2008-03-08 09:30:25Z bayard $
- */
-public interface Encoder {
-    
-    /**
-     * Encodes an "Object" and returns the encoded content 
-     * as an Object.  The Objects here may just be <code>byte[]</code>
-     * or <code>String</code>s depending on the implementation used.
-     *   
-     * @param pObject An object ot encode
-     * 
-     * @return An "encoded" Object
-     * 
-     * @throws EncoderException an encoder exception is
-     *  thrown if the encoder experiences a failure
-     *  condition during the encoding process.
-     */
-    Object encode(Object pObject) throws EncoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\language\Caverphone.java new\org\apache\commons\codec\language\Caverphone.java
--- old\org\apache\commons\codec\language\Caverphone.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\Caverphone.java	Thu Jan 01 01:00:00 1970
@@ -1,183 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Encodes a string into a Caverphone value.
- * 
- * This is an algorithm created the Caversham Project at the University of Otago. It implements the Caverphone 2.0
- * algorithm:
- * 
- * @author Apache Software Foundation
- * @version $Id: Caverphone.java 797690 2009-07-24 23:28:35Z ggregory $
- * @see <a href="http://en.wikipedia.org/wiki/Caverphone">Wikipedia - Caverphone</a>
- * @see <a href="http://caversham.otago.ac.nz/files/working/ctp150804.pdf">Caverphone 2.0 specification</a>
- * @since 1.4
- */
-public class Caverphone implements StringEncoder {
-
-    /**
-     * Creates an instance of the Caverphone encoder
-     */
-    public Caverphone() {
-        super();
-    }
-
-    /**
-     * Find the caverphone value of a String. 
-     *
-     * @param txt String to find the caverphone code for
-     * @return A caverphone code corresponding to the String supplied
-     */
-    public String caverphone(String txt) {
-        // NOTE: Version 1.0 of Caverphone is easily derivable from this code 
-        // by commenting out the 2.0 lines and adding in the 1.0 lines
-
-        if( txt == null || txt.length() == 0 ) {
-            return "1111111111";
-        }
-
-        // 1. Convert to lowercase
-        txt = txt.toLowerCase(java.util.Locale.ENGLISH);
-
-        // 2. Remove anything not A-Z
-        txt = txt.replaceAll("[^a-z]", "");
-
-        // 2.5. Remove final e
-        txt = txt.replaceAll("e$", "");             // 2.0 only
-
-        // 3. Handle various start options
-        txt = txt.replaceAll("^cough", "cou2f");
-        txt = txt.replaceAll("^rough", "rou2f");
-        txt = txt.replaceAll("^tough", "tou2f");
-        txt = txt.replaceAll("^enough", "enou2f");  // 2.0 only
-        txt = txt.replaceAll("^trough", "trou2f");  // 2.0 only - note the spec says ^enough here again, c+p error I assume
-        txt = txt.replaceAll("^gn", "2n");
-        txt = txt.replaceAll("^mb", "m2");
-
-        // 4. Handle replacements
-        txt = txt.replaceAll("cq", "2q");
-        txt = txt.replaceAll("ci", "si");
-        txt = txt.replaceAll("ce", "se");
-        txt = txt.replaceAll("cy", "sy");
-        txt = txt.replaceAll("tch", "2ch");
-        txt = txt.replaceAll("c", "k");
-        txt = txt.replaceAll("q", "k");
-        txt = txt.replaceAll("x", "k");
-        txt = txt.replaceAll("v", "f");
-        txt = txt.replaceAll("dg", "2g");
-        txt = txt.replaceAll("tio", "sio");
-        txt = txt.replaceAll("tia", "sia");
-        txt = txt.replaceAll("d", "t");
-        txt = txt.replaceAll("ph", "fh");
-        txt = txt.replaceAll("b", "p");
-        txt = txt.replaceAll("sh", "s2");
-        txt = txt.replaceAll("z", "s");
-        txt = txt.replaceAll("^[aeiou]", "A");
-        txt = txt.replaceAll("[aeiou]", "3");
-        txt = txt.replaceAll("j", "y");        // 2.0 only
-        txt = txt.replaceAll("^y3", "Y3");     // 2.0 only
-        txt = txt.replaceAll("^y", "A");       // 2.0 only
-        txt = txt.replaceAll("y", "3");        // 2.0 only
-        txt = txt.replaceAll("3gh3", "3kh3");
-        txt = txt.replaceAll("gh", "22");
-        txt = txt.replaceAll("g", "k");
-        txt = txt.replaceAll("s+", "S");
-        txt = txt.replaceAll("t+", "T");
-        txt = txt.replaceAll("p+", "P");
-        txt = txt.replaceAll("k+", "K");
-        txt = txt.replaceAll("f+", "F");
-        txt = txt.replaceAll("m+", "M");
-        txt = txt.replaceAll("n+", "N");
-        txt = txt.replaceAll("w3", "W3");
-        //txt = txt.replaceAll("wy", "Wy");    // 1.0 only
-        txt = txt.replaceAll("wh3", "Wh3");
-        txt = txt.replaceAll("w$", "3");       // 2.0 only
-        //txt = txt.replaceAll("why", "Why");  // 1.0 only
-        txt = txt.replaceAll("w", "2");
-        txt = txt.replaceAll("^h", "A");
-        txt = txt.replaceAll("h", "2");
-        txt = txt.replaceAll("r3", "R3");
-        txt = txt.replaceAll("r$", "3");       // 2.0 only
-        //txt = txt.replaceAll("ry", "Ry");    // 1.0 only
-        txt = txt.replaceAll("r", "2");
-        txt = txt.replaceAll("l3", "L3");
-        txt = txt.replaceAll("l$", "3");       // 2.0 only
-        //txt = txt.replaceAll("ly", "Ly");    // 1.0 only
-        txt = txt.replaceAll("l", "2");
-        //txt = txt.replaceAll("j", "y");      // 1.0 only
-        //txt = txt.replaceAll("y3", "Y3");    // 1.0 only
-        //txt = txt.replaceAll("y", "2");      // 1.0 only
-
-        // 5. Handle removals
-        txt = txt.replaceAll("2", "");
-        txt = txt.replaceAll("3$", "A");       // 2.0 only
-        txt = txt.replaceAll("3", "");
-
-        // 6. put ten 1s on the end
-        txt = txt + "111111" + "1111";        // 1.0 only has 6 1s
-
-        // 7. take the first six characters as the code
-        return txt.substring(0, 10);          // 1.0 truncates to 6
-    }
-
-    /**
-     * Encodes an Object using the caverphone algorithm.  This method
-     * is provided in order to satisfy the requirements of the
-     * Encoder interface, and will throw an EncoderException if the
-     * supplied object is not of type java.lang.String.
-     *
-     * @param pObject Object to encode
-     * @return An object (or type java.lang.String) containing the 
-     *         caverphone code which corresponds to the String supplied.
-     * @throws EncoderException if the parameter supplied is not
-     *                          of type java.lang.String
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (!(pObject instanceof String)) {
-            throw new EncoderException("Parameter supplied to Caverphone encode is not of type java.lang.String"); 
-        }
-        return caverphone((String) pObject);
-    }
-
-    /**
-     * Encodes a String using the Caverphone algorithm. 
-     *
-     * @param pString String object to encode
-     * @return The caverphone code corresponding to the String supplied
-     */
-    public String encode(String pString) {
-        return caverphone(pString);   
-    }
-
-    /**
-     * Tests if the caverphones of two strings are identical.
-     *
-     * @param str1 First of two strings to compare
-     * @param str2 Second of two strings to compare
-     * @return <code>true</code> if the caverphones of these strings are identical, 
-     *        <code>false</code> otherwise.
-     */
-    public boolean isCaverphoneEqual(String str1, String str2) {
-        return caverphone(str1).equals(caverphone(str2));
-    }
-
-}
diff -Nru old\org\apache\commons\codec\language\DoubleMetaphone.java new\org\apache\commons\codec\language\DoubleMetaphone.java
--- old\org\apache\commons\codec\language\DoubleMetaphone.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\DoubleMetaphone.java	Thu Jan 01 01:00:00 1970
@@ -1,1105 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Encodes a string into a double metaphone value.
- * This Implementation is based on the algorithm by <CITE>Lawrence Philips</CITE>.
- * <ul>
- * <li>Original Article: <a 
- * href="http://www.cuj.com/documents/s=8038/cuj0006philips/">
- * http://www.cuj.com/documents/s=8038/cuj0006philips/</a></li>
- * <li>Original Source Code: <a href="ftp://ftp.cuj.com/pub/2000/1806/philips.zip">
- * ftp://ftp.cuj.com/pub/2000/1806/philips.zip</a></li>
- * </ul>
- * 
- * @author Apache Software Foundation
- * @version $Id: DoubleMetaphone.java 800153 2009-08-02 22:45:30Z ggregory $
- */
-public class DoubleMetaphone implements StringEncoder {
-
-    /**
-     * "Vowels" to test for
-     */
-    private static final String VOWELS = "AEIOUY";
-
-    /**
-     * Prefixes when present which are not pronounced
-     */
-    private static final String[] SILENT_START = 
-    { "GN", "KN", "PN", "WR", "PS" };
-    private static final String[] L_R_N_M_B_H_F_V_W_SPACE = 
-    { "L", "R", "N", "M", "B", "H", "F", "V", "W", " " };
-    private static final String[] ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER = 
-    { "ES", "EP", "EB", "EL", "EY", "IB", "IL", "IN", "IE", "EI", "ER" };
-    private static final String[] L_T_K_S_N_M_B_Z = 
-    { "L", "T", "K", "S", "N", "M", "B", "Z" };
-
-    /**
-     * Maximum length of an encoding, default is 4
-     */
-    protected int maxCodeLen = 4;
-
-    /**
-     * Creates an instance of this DoubleMetaphone encoder
-     */
-    public DoubleMetaphone() {
-        super();
-    }
-    
-    /**
-     * Encode a value with Double Metaphone
-     *
-     * @param value String to encode
-     * @return an encoded string
-     */
-    public String doubleMetaphone(String value) {
-        return doubleMetaphone(value, false);
-    }
-    
-    /**
-     * Encode a value with Double Metaphone, optionally using the alternate
-     * encoding.
-     *
-     * @param value String to encode
-     * @param alternate use alternate encode
-     * @return an encoded string
-     */
-    public String doubleMetaphone(String value, boolean alternate) {
-        value = cleanInput(value);
-        if (value == null) {
-            return null;
-        }
-        
-        boolean slavoGermanic = isSlavoGermanic(value);
-        int index = isSilentStart(value) ? 1 : 0;
-        
-        DoubleMetaphoneResult result = new DoubleMetaphoneResult(this.getMaxCodeLen());
-        
-        while (!result.isComplete() && index <= value.length() - 1) {
-            switch (value.charAt(index)) {
-            case 'A':
-            case 'E':
-            case 'I':
-            case 'O':
-            case 'U':
-            case 'Y':
-                index = handleAEIOUY(value, result, index);
-                break;
-            case 'B':
-                result.append('P');
-                index = charAt(value, index + 1) == 'B' ? index + 2 : index + 1;
-                break;
-            case '\u00C7':
-                // A C with a Cedilla
-                result.append('S');
-                index++;
-                break; 
-            case 'C':
-                index = handleC(value, result, index);
-                break;
-            case 'D':
-                index = handleD(value, result, index);
-                break;
-            case 'F':
-                result.append('F');
-                index = charAt(value, index + 1) == 'F' ? index + 2 : index + 1;
-                break;
-            case 'G':
-                index = handleG(value, result, index, slavoGermanic);
-                break;
-            case 'H':
-                index = handleH(value, result, index);
-                break;
-            case 'J':
-                index = handleJ(value, result, index, slavoGermanic);
-                break;
-            case 'K':
-                result.append('K');
-                index = charAt(value, index + 1) == 'K' ? index + 2 : index + 1;
-                break;
-            case 'L':
-                index = handleL(value, result, index);
-                break;
-            case 'M':
-                result.append('M');
-                index = conditionM0(value, index) ? index + 2 : index + 1;
-                break;
-            case 'N':
-                result.append('N');
-                index = charAt(value, index + 1) == 'N' ? index + 2 : index + 1;
-                break;
-            case '\u00D1':
-                // N with a tilde (spanish ene)
-                result.append('N');
-                index++;
-                break;
-            case 'P':
-                index = handleP(value, result, index);
-                break;
-            case 'Q':
-                result.append('K');
-                index = charAt(value, index + 1) == 'Q' ? index + 2 : index + 1;
-                break;
-            case 'R':
-                index = handleR(value, result, index, slavoGermanic);
-                break;
-            case 'S':
-                index = handleS(value, result, index, slavoGermanic);
-                break;
-            case 'T':
-                index = handleT(value, result, index);
-                break;
-            case 'V':
-                result.append('F');
-                index = charAt(value, index + 1) == 'V' ? index + 2 : index + 1;
-                break;
-            case 'W':
-                index = handleW(value, result, index);
-                break;
-            case 'X':
-                index = handleX(value, result, index);
-                break;
-            case 'Z':
-                index = handleZ(value, result, index, slavoGermanic);
-                break;
-            default:
-                index++;
-                break;
-            }
-        }
-
-        return alternate ? result.getAlternate() : result.getPrimary();
-    }
-    
-    /**
-     * Encode the value using DoubleMetaphone.  It will only work if 
-     * <code>obj</code> is a <code>String</code> (like <code>Metaphone</code>).
-     *
-     * @param obj Object to encode (should be of type String)
-     * @return An encoded Object (will be of type String)
-     * @throws EncoderException encode parameter is not of type String
-     */
-    public Object encode(Object obj) throws EncoderException {
-        if (!(obj instanceof String)) {
-            throw new EncoderException("DoubleMetaphone encode parameter is not of type String"); 
-        } 
-        return doubleMetaphone((String) obj);
-    }
-
-    /**
-     * Encode the value using DoubleMetaphone.
-     *
-     * @param value String to encode
-     * @return An encoded String
-     */
-    public String encode(String value) {
-        return doubleMetaphone(value);   
-    }
-
-    /**
-     * Check if the Double Metaphone values of two <code>String</code> values
-     * are equal.
-     * 
-     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
-     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
-     * @return <code>true</code> if the encoded <code>String</code>s are equal;
-     *          <code>false</code> otherwise.
-     * @see #isDoubleMetaphoneEqual(String,String,boolean)
-     */
-    public boolean isDoubleMetaphoneEqual(String value1, String value2) {
-        return isDoubleMetaphoneEqual(value1, value2, false);
-    }
-    
-    /**
-     * Check if the Double Metaphone values of two <code>String</code> values
-     * are equal, optionally using the alternate value.
-     * 
-     * @param value1 The left-hand side of the encoded {@link String#equals(Object)}.
-     * @param value2 The right-hand side of the encoded {@link String#equals(Object)}.
-     * @param alternate use the alternate value if <code>true</code>.
-     * @return <code>true</code> if the encoded <code>String</code>s are equal;
-     *          <code>false</code> otherwise.
-     */
-    public boolean isDoubleMetaphoneEqual(String value1, 
-                                          String value2, 
-                                          boolean alternate) {
-        return doubleMetaphone(value1, alternate).equals(doubleMetaphone
-                                                         (value2, alternate));
-    }
-    
-    /**
-     * Returns the maxCodeLen.
-     * @return int
-     */
-    public int getMaxCodeLen() {
-        return this.maxCodeLen;
-    }
-
-    /**
-     * Sets the maxCodeLen.
-     * @param maxCodeLen The maxCodeLen to set
-     */
-    public void setMaxCodeLen(int maxCodeLen) {
-        this.maxCodeLen = maxCodeLen;
-    }
-
-    //-- BEGIN HANDLERS --//
-
-    /**
-     * Handles 'A', 'E', 'I', 'O', 'U', and 'Y' cases
-     */
-    private int handleAEIOUY(String value, DoubleMetaphoneResult result, int 
-                             index) {
-        if (index == 0) {
-            result.append('A');
-        }
-        return index + 1;
-    }
-    
-    /**
-     * Handles 'C' cases
-     */
-    private int handleC(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (conditionC0(value, index)) {  // very confusing, moved out
-            result.append('K');
-            index += 2;
-        } else if (index == 0 && contains(value, index, 6, "CAESAR")) {
-            result.append('S');
-            index += 2;
-        } else if (contains(value, index, 2, "CH")) {
-            index = handleCH(value, result, index);
-        } else if (contains(value, index, 2, "CZ") && 
-                   !contains(value, index - 2, 4, "WICZ")) {
-            //-- "Czerny" --//
-            result.append('S', 'X');
-            index += 2;
-        } else if (contains(value, index + 1, 3, "CIA")) {
-            //-- "focaccia" --//
-            result.append('X');
-            index += 3;
-        } else if (contains(value, index, 2, "CC") && 
-                   !(index == 1 && charAt(value, 0) == 'M')) {
-            //-- double "cc" but not "McClelland" --//
-            return handleCC(value, result, index);
-        } else if (contains(value, index, 2, "CK", "CG", "CQ")) {
-            result.append('K');
-            index += 2;
-        } else if (contains(value, index, 2, "CI", "CE", "CY")) {
-            //-- Italian vs. English --//
-            if (contains(value, index, 3, "CIO", "CIE", "CIA")) {
-                result.append('S', 'X');
-            } else {
-                result.append('S');
-            }
-            index += 2;
-        } else {
-            result.append('K');
-            if (contains(value, index + 1, 2, " C", " Q", " G")) { 
-                //-- Mac Caffrey, Mac Gregor --//
-                index += 3;
-            } else if (contains(value, index + 1, 1, "C", "K", "Q") && 
-                       !contains(value, index + 1, 2, "CE", "CI")) {
-                index += 2;
-            } else {
-                index++;
-            }
-        }
-        
-        return index;
-    }
-
-    /**
-     * Handles 'CC' cases
-     */
-    private int handleCC(String value, 
-                         DoubleMetaphoneResult result, 
-                         int index) {
-        if (contains(value, index + 2, 1, "I", "E", "H") && 
-            !contains(value, index + 2, 2, "HU")) {
-            //-- "bellocchio" but not "bacchus" --//
-            if ((index == 1 && charAt(value, index - 1) == 'A') || 
-                contains(value, index - 1, 5, "UCCEE", "UCCES")) {
-                //-- "accident", "accede", "succeed" --//
-                result.append("KS");
-            } else {
-                //-- "bacci", "bertucci", other Italian --//
-                result.append('X');
-            }
-            index += 3;
-        } else {    // Pierce's rule
-            result.append('K');
-            index += 2;
-        }
-        
-        return index;
-    }
-    
-    /**
-     * Handles 'CH' cases
-     */
-    private int handleCH(String value, 
-                         DoubleMetaphoneResult result, 
-                         int index) {
-        if (index > 0 && contains(value, index, 4, "CHAE")) {   // Michael
-            result.append('K', 'X');
-            return index + 2;
-        } else if (conditionCH0(value, index)) {
-            //-- Greek roots ("chemistry", "chorus", etc.) --//
-            result.append('K');
-            return index + 2;
-        } else if (conditionCH1(value, index)) {
-            //-- Germanic, Greek, or otherwise 'ch' for 'kh' sound --//
-            result.append('K');
-            return index + 2;
-        } else {
-            if (index > 0) {
-                if (contains(value, 0, 2, "MC")) {
-                    result.append('K');
-                } else {
-                    result.append('X', 'K');
-                }
-            } else {
-                result.append('X');
-            }
-            return index + 2;
-        }
-    }
-
-    /**
-     * Handles 'D' cases
-     */
-    private int handleD(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (contains(value, index, 2, "DG")) {
-            //-- "Edge" --//
-            if (contains(value, index + 2, 1, "I", "E", "Y")) {
-                result.append('J');
-                index += 3;
-                //-- "Edgar" --//
-            } else {
-                result.append("TK");
-                index += 2;
-            }
-        } else if (contains(value, index, 2, "DT", "DD")) {
-            result.append('T');
-            index += 2;
-        } else {
-            result.append('T');
-            index++;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'G' cases
-     */
-    private int handleG(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index, 
-                        boolean slavoGermanic) {
-        if (charAt(value, index + 1) == 'H') {
-            index = handleGH(value, result, index);
-        } else if (charAt(value, index + 1) == 'N') {
-            if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) {
-                result.append("KN", "N");
-            } else if (!contains(value, index + 2, 2, "EY") && 
-                       charAt(value, index + 1) != 'Y' && !slavoGermanic) {
-                result.append("N", "KN");
-            } else {
-                result.append("KN");
-            }
-            index = index + 2;
-        } else if (contains(value, index + 1, 2, "LI") && !slavoGermanic) {
-            result.append("KL", "L");
-            index += 2;
-        } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) {
-            //-- -ges-, -gep-, -gel-, -gie- at beginning --//
-            result.append('K', 'J');
-            index += 2;
-        } else if ((contains(value, index + 1, 2, "ER") || 
-                    charAt(value, index + 1) == 'Y') &&
-                   !contains(value, 0, 6, "DANGER", "RANGER", "MANGER") &&
-                   !contains(value, index - 1, 1, "E", "I") && 
-                   !contains(value, index - 1, 3, "RGY", "OGY")) {
-            //-- -ger-, -gy- --//
-            result.append('K', 'J');
-            index += 2;
-        } else if (contains(value, index + 1, 1, "E", "I", "Y") || 
-                   contains(value, index - 1, 4, "AGGI", "OGGI")) {
-            //-- Italian "biaggi" --//
-            if ((contains(value, 0 ,4, "VAN ", "VON ") || contains(value, 0, 3, "SCH")) || contains(value, index + 1, 2, "ET")) {
-                //-- obvious germanic --//
-                result.append('K');
-            } else if (contains(value, index + 1, 3, "IER")) {
-                result.append('J');
-            } else {
-                result.append('J', 'K');
-            }
-            index += 2;
-        } else if (charAt(value, index + 1) == 'G') {
-            index += 2;
-            result.append('K');
-        } else {
-            index++;
-            result.append('K');
-        }
-        return index;
-    }
-    
-    /**
-     * Handles 'GH' cases
-     */
-    private int handleGH(String value, 
-                         DoubleMetaphoneResult result, 
-                         int index) {
-        if (index > 0 && !isVowel(charAt(value, index - 1))) {
-            result.append('K');
-            index += 2;
-        } else if (index == 0) {
-            if (charAt(value, index + 2) == 'I') {
-                result.append('J');
-            } else {
-                result.append('K');
-            }
-            index += 2;
-        } else if ((index > 1 && contains(value, index - 2, 1, "B", "H", "D")) ||
-                   (index > 2 && contains(value, index - 3, 1, "B", "H", "D")) ||
-                   (index > 3 && contains(value, index - 4, 1, "B", "H"))) {
-            //-- Parker's rule (with some further refinements) - "hugh"
-            index += 2;
-        } else {
-            if (index > 2 && charAt(value, index - 1) == 'U' && 
-                contains(value, index - 3, 1, "C", "G", "L", "R", "T")) {
-                //-- "laugh", "McLaughlin", "cough", "gough", "rough", "tough"
-                result.append('F');
-            } else if (index > 0 && charAt(value, index - 1) != 'I') {
-                result.append('K');
-            }
-            index += 2;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'H' cases
-     */
-    private int handleH(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        //-- only keep if first & before vowel or between 2 vowels --//
-        if ((index == 0 || isVowel(charAt(value, index - 1))) && 
-            isVowel(charAt(value, index + 1))) {
-            result.append('H');
-            index += 2;
-            //-- also takes car of "HH" --//
-        } else {
-            index++;
-        }
-        return index;
-    }
-    
-    /**
-     * Handles 'J' cases
-     */
-    private int handleJ(String value, DoubleMetaphoneResult result, int index, 
-                        boolean slavoGermanic) {
-        if (contains(value, index, 4, "JOSE") || contains(value, 0, 4, "SAN ")) {
-                //-- obvious Spanish, "Jose", "San Jacinto" --//
-                if ((index == 0 && (charAt(value, index + 4) == ' ') || 
-                     value.length() == 4) || contains(value, 0, 4, "SAN ")) {
-                    result.append('H');
-                } else {
-                    result.append('J', 'H');
-                }
-                index++;
-            } else {
-                if (index == 0 && !contains(value, index, 4, "JOSE")) {
-                    result.append('J', 'A');
-                } else if (isVowel(charAt(value, index - 1)) && !slavoGermanic && 
-                              (charAt(value, index + 1) == 'A' || charAt(value, index + 1) == 'O')) {
-                    result.append('J', 'H');
-                } else if (index == value.length() - 1) {
-                    result.append('J', ' ');
-                } else if (!contains(value, index + 1, 1, L_T_K_S_N_M_B_Z) && !contains(value, index - 1, 1, "S", "K", "L")) {
-                    result.append('J');
-                }
-
-                if (charAt(value, index + 1) == 'J') {
-                    index += 2;
-                } else {
-                    index++;
-                }
-            }
-        return index;
-    }
-    
-    /**
-     * Handles 'L' cases
-     */
-    private int handleL(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (charAt(value, index + 1) == 'L') {
-            if (conditionL0(value, index)) {
-                result.appendPrimary('L');
-            } else {
-                result.append('L');
-            }
-            index += 2;
-        } else {
-            index++;
-            result.append('L');
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'P' cases
-     */
-    private int handleP(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (charAt(value, index + 1) == 'H') {
-            result.append('F');
-            index += 2;
-        } else {
-            result.append('P');
-            index = contains(value, index + 1, 1, "P", "B") ? index + 2 : index + 1;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'R' cases
-     */
-    private int handleR(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index, 
-                        boolean slavoGermanic) {
-        if (index == value.length() - 1 && !slavoGermanic && 
-            contains(value, index - 2, 2, "IE") && 
-            !contains(value, index - 4, 2, "ME", "MA")) {
-            result.appendAlternate('R');
-        } else {
-            result.append('R');
-        }
-        return charAt(value, index + 1) == 'R' ? index + 2 : index + 1;
-    }
-
-    /**
-     * Handles 'S' cases
-     */
-    private int handleS(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index, 
-                        boolean slavoGermanic) {
-        if (contains(value, index - 1, 3, "ISL", "YSL")) {
-            //-- special cases "island", "isle", "carlisle", "carlysle" --//
-            index++;
-        } else if (index == 0 && contains(value, index, 5, "SUGAR")) {
-            //-- special case "sugar-" --//
-            result.append('X', 'S');
-            index++;
-        } else if (contains(value, index, 2, "SH")) {
-            if (contains(value, index + 1, 4, 
-                         "HEIM", "HOEK", "HOLM", "HOLZ")) {
-                //-- germanic --//
-                result.append('S');
-            } else {
-                result.append('X');
-            }
-            index += 2;
-        } else if (contains(value, index, 3, "SIO", "SIA") || contains(value, index, 4, "SIAN")) {
-            //-- Italian and Armenian --//
-            if (slavoGermanic) {
-                result.append('S');
-            } else {
-                result.append('S', 'X');
-            }
-            index += 3;
-        } else if ((index == 0 && contains(value, index + 1, 1, "M", "N", "L", "W")) || contains(value, index + 1, 1, "Z")) {
-            //-- german & anglicisations, e.g. "smith" match "schmidt" //
-            // "snider" match "schneider" --//
-            //-- also, -sz- in slavic language altho in hungarian it //
-            //   is pronounced "s" --//
-            result.append('S', 'X');
-            index = contains(value, index + 1, 1, "Z") ? index + 2 : index + 1;
-        } else if (contains(value, index, 2, "SC")) {
-            index = handleSC(value, result, index);
-        } else {
-            if (index == value.length() - 1 && contains(value, index - 2, 
-                                                        2, "AI", "OI")){
-                //-- french e.g. "resnais", "artois" --//
-                result.appendAlternate('S');
-            } else {
-                result.append('S');
-            }
-            index = contains(value, index + 1, 1, "S", "Z") ? index + 2 : index + 1;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'SC' cases
-     */
-    private int handleSC(String value, 
-                         DoubleMetaphoneResult result, 
-                         int index) {
-        if (charAt(value, index + 2) == 'H') {
-            //-- Schlesinger's rule --//
-            if (contains(value, index + 3, 
-                         2, "OO", "ER", "EN", "UY", "ED", "EM")) {
-                //-- Dutch origin, e.g. "school", "schooner" --//
-                if (contains(value, index + 3, 2, "ER", "EN")) {
-                    //-- "schermerhorn", "schenker" --//
-                    result.append("X", "SK");
-                } else {
-                    result.append("SK");
-                }
-            } else {
-                if (index == 0 && !isVowel(charAt(value, 3)) && charAt(value, 3) != 'W') {
-                    result.append('X', 'S');
-                } else {
-                    result.append('X');
-                }
-            }
-        } else if (contains(value, index + 2, 1, "I", "E", "Y")) {
-            result.append('S');
-        } else {
-            result.append("SK");
-        }
-        return index + 3;
-    }
-
-    /**
-     * Handles 'T' cases
-     */
-    private int handleT(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (contains(value, index, 4, "TION")) {
-            result.append('X');
-            index += 3;
-        } else if (contains(value, index, 3, "TIA", "TCH")) {
-            result.append('X');
-            index += 3;
-        } else if (contains(value, index, 2, "TH") || contains(value, index, 
-                                                               3, "TTH")) {
-            if (contains(value, index + 2, 2, "OM", "AM") || 
-                //-- special case "thomas", "thames" or germanic --//
-                contains(value, 0, 4, "VAN ", "VON ") || 
-                contains(value, 0, 3, "SCH")) {
-                result.append('T');
-            } else {
-                result.append('0', 'T');
-            }
-            index += 2;
-        } else {
-            result.append('T');
-            index = contains(value, index + 1, 1, "T", "D") ? index + 2 : index + 1;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'W' cases
-     */
-    private int handleW(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (contains(value, index, 2, "WR")) {
-            //-- can also be in middle of word --//
-            result.append('R');
-            index += 2;
-        } else {
-            if (index == 0 && (isVowel(charAt(value, index + 1)) || 
-                               contains(value, index, 2, "WH"))) {
-                if (isVowel(charAt(value, index + 1))) {
-                    //-- Wasserman should match Vasserman --//
-                    result.append('A', 'F');
-                } else {
-                    //-- need Uomo to match Womo --//
-                    result.append('A');
-                }
-                index++;
-            } else if ((index == value.length() - 1 && isVowel(charAt(value, index - 1))) ||
-                       contains(value, index - 1, 
-                                5, "EWSKI", "EWSKY", "OWSKI", "OWSKY") ||
-                       contains(value, 0, 3, "SCH")) {
-                //-- Arnow should match Arnoff --//
-                result.appendAlternate('F');
-                index++;
-            } else if (contains(value, index, 4, "WICZ", "WITZ")) {
-                //-- Polish e.g. "filipowicz" --//
-                result.append("TS", "FX");
-                index += 4;
-            } else {
-                index++;
-            }
-        }
-        return index;
-    }
-    
-    /**
-     * Handles 'X' cases
-     */
-    private int handleX(String value, 
-                        DoubleMetaphoneResult result, 
-                        int index) {
-        if (index == 0) {
-            result.append('S');
-            index++;
-        } else {
-            if (!((index == value.length() - 1) && 
-                  (contains(value, index - 3, 3, "IAU", "EAU") || 
-                   contains(value, index - 2, 2, "AU", "OU")))) {
-                //-- French e.g. breaux --//
-                result.append("KS");
-            }
-            index = contains(value, index + 1, 1, "C", "X") ? index + 2 : index + 1;
-        }
-        return index;
-    }
-
-    /**
-     * Handles 'Z' cases
-     */
-    private int handleZ(String value, DoubleMetaphoneResult result, int index, 
-                        boolean slavoGermanic) {
-        if (charAt(value, index + 1) == 'H') {
-            //-- Chinese pinyin e.g. "zhao" or Angelina "Zhang" --//
-            result.append('J');
-            index += 2;
-        } else {
-            if (contains(value, index + 1, 2, "ZO", "ZI", "ZA") || (slavoGermanic && (index > 0 && charAt(value, index - 1) != 'T'))) {
-                result.append("S", "TS");
-            } else {
-                result.append('S');
-            }
-            index = charAt(value, index + 1) == 'Z' ? index + 2 : index + 1;
-        }
-        return index;
-    }
-
-    //-- BEGIN CONDITIONS --//
-
-    /**
-     * Complex condition 0 for 'C'
-     */
-    private boolean conditionC0(String value, int index) {
-        if (contains(value, index, 4, "CHIA")) {
-            return true;
-        } else if (index <= 1) {
-            return false;
-        } else if (isVowel(charAt(value, index - 2))) {
-            return false;
-        } else if (!contains(value, index - 1, 3, "ACH")) {
-            return false;
-        } else {
-            char c = charAt(value, index + 2);
-            return (c != 'I' && c != 'E') ||
-                    contains(value, index - 2, 6, "BACHER", "MACHER");
-        }
-    }
-    
-    /**
-     * Complex condition 0 for 'CH'
-     */
-    private boolean conditionCH0(String value, int index) {
-        if (index != 0) {
-            return false;
-        } else if (!contains(value, index + 1, 5, "HARAC", "HARIS") && 
-                   !contains(value, index + 1, 3, "HOR", "HYM", "HIA", "HEM")) {
-            return false;
-        } else if (contains(value, 0, 5, "CHORE")) {
-            return false;
-        } else {
-            return true;
-        }
-    }
-    
-    /**
-     * Complex condition 1 for 'CH'
-     */
-    private boolean conditionCH1(String value, int index) {
-        return ((contains(value, 0, 4, "VAN ", "VON ") || contains(value, 0, 
-                                                                   3, "SCH")) ||
-                contains(value, index - 2, 6, "ORCHES", "ARCHIT", "ORCHID") ||
-                contains(value, index + 2, 1, "T", "S") ||
-                ((contains(value, index - 1, 1, "A", "O", "U", "E") || index == 0) &&
-                 (contains(value, index + 2, 1, L_R_N_M_B_H_F_V_W_SPACE) || index + 1 == value.length() - 1)));
-    }
-    
-    /**
-     * Complex condition 0 for 'L'
-     */
-    private boolean conditionL0(String value, int index) {
-        if (index == value.length() - 3 && 
-            contains(value, index - 1, 4, "ILLO", "ILLA", "ALLE")) {
-            return true;
-        } else if ((contains(value, value.length() - 2, 2, "AS", "OS") || 
-                    contains(value, value.length() - 1, 1, "A", "O")) &&
-                   contains(value, index - 1, 4, "ALLE")) {
-            return true;
-        } else {
-            return false;
-        }
-    }
-    
-    /**
-     * Complex condition 0 for 'M'
-     */
-    private boolean conditionM0(String value, int index) {
-        if (charAt(value, index + 1) == 'M') {
-            return true;
-        }
-        return contains(value, index - 1, 3, "UMB") &&
-                ((index + 1) == value.length() - 1 || contains(value,
-                        index + 2, 2, "ER"));
-    }
-    
-    //-- BEGIN HELPER FUNCTIONS --//
-
-    /**
-     * Determines whether or not a value is of slavo-germanic orgin. A value is
-     * of slavo-germanic origin if it contians any of 'W', 'K', 'CZ', or 'WITZ'.
-     */
-    private boolean isSlavoGermanic(String value) {
-        return value.indexOf('W') > -1 || value.indexOf('K') > -1 || 
-            value.indexOf("CZ") > -1 || value.indexOf("WITZ") > -1;
-    }
-
-    /**
-     * Determines whether or not a character is a vowel or not
-     */
-    private boolean isVowel(char ch) {
-        return VOWELS.indexOf(ch) != -1;
-    }
-
-    /**
-     * Determines whether or not the value starts with a silent letter.  It will
-     * return <code>true</code> if the value starts with any of 'GN', 'KN',
-     * 'PN', 'WR' or 'PS'.
-     */    
-    private boolean isSilentStart(String value) {
-        boolean result = false;
-        for (int i = 0; i < SILENT_START.length; i++) {
-            if (value.startsWith(SILENT_START[i])) {
-                result = true;
-                break;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Cleans the input
-     */    
-    private String cleanInput(String input) {
-        if (input == null) {
-            return null;
-        }
-        input = input.trim();
-        if (input.length() == 0) {
-            return null;
-        }
-        return input.toUpperCase(java.util.Locale.ENGLISH);
-    }
-
-    /**
-     * Gets the character at index <code>index</code> if available, otherwise
-     * it returns <code>Character.MIN_VALUE</code> so that there is some sort
-     * of a default
-     */    
-    protected char charAt(String value, int index) {
-        if (index < 0 || index >= value.length()) {
-            return Character.MIN_VALUE;
-        } 
-        return value.charAt(index);
-    }
-
-    /**
-     * Shortcut method with 1 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria) {
-        return contains(value, start, length, 
-                        new String[] { criteria });
-    }
-
-    /**
-     * Shortcut method with 2 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria1, String criteria2) {
-        return contains(value, start, length, 
-                        new String[] { criteria1, criteria2 });
-    }
-
-    /**
-     * Shortcut method with 3 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria1, String criteria2, 
-                                    String criteria3) {
-        return contains(value, start, length, 
-                        new String[] { criteria1, criteria2, criteria3 });
-    }
-
-    /**
-     * Shortcut method with 4 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria1, String criteria2, 
-                                    String criteria3, String criteria4) {
-        return contains(value, start, length, 
-                        new String[] { criteria1, criteria2, criteria3, 
-                                       criteria4 });
-    }
-
-    /**
-     * Shortcut method with 5 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria1, String criteria2, 
-                                    String criteria3, String criteria4, 
-                                    String criteria5) {
-        return contains(value, start, length, 
-                        new String[] { criteria1, criteria2, criteria3, 
-                                       criteria4, criteria5 });
-    }
-
-    /**
-     * Shortcut method with 6 criteria
-     */    
-    private static boolean contains(String value, int start, int length, 
-                                    String criteria1, String criteria2, 
-                                    String criteria3, String criteria4, 
-                                    String criteria5, String criteria6) {
-        return contains(value, start, length, 
-                        new String[] { criteria1, criteria2, criteria3, 
-                                       criteria4, criteria5, criteria6 });
-    }
-    
-    /**
-     * Determines whether <code>value</code> contains any of the criteria starting at index <code>start</code> and
-     * matching up to length <code>length</code>
-     */
-    protected static boolean contains(String value, int start, int length, 
-                                      String[] criteria) {
-        boolean result = false;
-        if (start >= 0 && start + length <= value.length()) {
-            String target = value.substring(start, start + length);
-
-            for (int i = 0; i < criteria.length; i++) {
-                if (target.equals(criteria[i])) {
-                    result = true;
-                    break;
-                }
-            }
-        }
-        return result;
-    }
-    
-    //-- BEGIN INNER CLASSES --//
-    
-    /**
-     * Inner class for storing results, since there is the optional alternate
-     * encoding.
-     */
-    public class DoubleMetaphoneResult {
-
-        private StringBuffer primary = new StringBuffer(getMaxCodeLen());
-        private StringBuffer alternate = new StringBuffer(getMaxCodeLen());
-        private int maxLength;
-
-        public DoubleMetaphoneResult(int maxLength) {
-            this.maxLength = maxLength;
-        }
-
-        public void append(char value) {
-            appendPrimary(value);
-            appendAlternate(value);
-        }
-
-        public void append(char primary, char alternate) {
-            appendPrimary(primary);
-            appendAlternate(alternate);
-        }
-
-        public void appendPrimary(char value) {
-            if (this.primary.length() < this.maxLength) {
-                this.primary.append(value);
-            }
-        }
-
-        public void appendAlternate(char value) {
-            if (this.alternate.length() < this.maxLength) {
-                this.alternate.append(value);
-            }
-        }
-
-        public void append(String value) {
-            appendPrimary(value);
-            appendAlternate(value);
-        }
-
-        public void append(String primary, String alternate) {
-            appendPrimary(primary);
-            appendAlternate(alternate);
-        }
-
-        public void appendPrimary(String value) {
-            int addChars = this.maxLength - this.primary.length();
-            if (value.length() <= addChars) {
-                this.primary.append(value);
-            } else {
-                this.primary.append(value.substring(0, addChars));
-            }
-        }
-
-        public void appendAlternate(String value) {
-            int addChars = this.maxLength - this.alternate.length();
-            if (value.length() <= addChars) {
-                this.alternate.append(value);
-            } else {
-                this.alternate.append(value.substring(0, addChars));
-            }
-        }
-
-        public String getPrimary() {
-            return this.primary.toString();
-        }
-
-        public String getAlternate() {
-            return this.alternate.toString();
-        }
-
-        public boolean isComplete() {
-            return this.primary.length() >= this.maxLength && 
-                this.alternate.length() >= this.maxLength;
-        }
-    }
-}
diff -Nru old\org\apache\commons\codec\language\Metaphone.java new\org\apache\commons\codec\language\Metaphone.java
--- old\org\apache\commons\codec\language\Metaphone.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\Metaphone.java	Thu Jan 01 01:00:00 1970
@@ -1,407 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Encodes a string into a metaphone value. 
- * <p>
- * Initial Java implementation by <CITE>William B. Brogden. December, 1997</CITE>. 
- * Permission given by <CITE>wbrogden</CITE> for code to be used anywhere.
- * </p>
- * <p>
- * <CITE>Hanging on the Metaphone</CITE> by <CITE>Lawrence Philips</CITE> in <CITE>Computer Language of Dec. 1990, p
- * 39.</CITE>
- * </p>
- * <p>
- * Note, that this does not match the algorithm that ships with PHP, or the algorithm 
- * found in the Perl <a href="http://search.cpan.org/~mschwern/Text-Metaphone-1.96/Metaphone.pm">Text:Metaphone-1.96</a>.
- * They have had undocumented changes from the originally published algorithm. 
- * For more information, see <a href="https://issues.apache.org/jira/browse/CODEC-57">CODEC-57</a>.
- * </p>
- * 
- * @author Apache Software Foundation
- * @version $Id: Metaphone.java 797690 2009-07-24 23:28:35Z ggregory $
- */
-public class Metaphone implements StringEncoder {
-
-    /**
-     * Five values in the English language 
-     */
-    private static final String VOWELS = "AEIOU" ;
-
-    /**
-     * Variable used in Metaphone algorithm
-     */
-    private static final String FRONTV = "EIY"   ;
-
-    /**
-     * Variable used in Metaphone algorithm
-     */
-    private static final String VARSON = "CSPTG" ;
-
-    /**
-     * The max code length for metaphone is 4
-     */
-    private int maxCodeLen = 4 ;
-
-    /**
-     * Creates an instance of the Metaphone encoder
-     */
-    public Metaphone() {
-        super();
-    }
-
-    /**
-     * Find the metaphone value of a String. This is similar to the
-     * soundex algorithm, but better at finding similar sounding words.
-     * All input is converted to upper case.
-     * Limitations: Input format is expected to be a single ASCII word
-     * with only characters in the A - Z range, no punctuation or numbers.
-     *
-     * @param txt String to find the metaphone code for
-     * @return A metaphone code corresponding to the String supplied
-     */
-    public String metaphone(String txt) {
-        boolean hard = false ;
-        if ((txt == null) || (txt.length() == 0)) {
-            return "" ;
-        }
-        // single character is itself
-        if (txt.length() == 1) {
-            return txt.toUpperCase(java.util.Locale.ENGLISH) ;
-        }
-      
-        char[] inwd = txt.toUpperCase(java.util.Locale.ENGLISH).toCharArray() ;
-      
-        StringBuffer local = new StringBuffer(40); // manipulate
-        StringBuffer code = new StringBuffer(10) ; //   output
-        // handle initial 2 characters exceptions
-        switch(inwd[0]) {
-        case 'K' : 
-        case 'G' : 
-        case 'P' : /* looking for KN, etc*/
-            if (inwd[1] == 'N') {
-                local.append(inwd, 1, inwd.length - 1);
-            } else {
-                local.append(inwd);
-            }
-            break;
-        case 'A': /* looking for AE */
-            if (inwd[1] == 'E') {
-                local.append(inwd, 1, inwd.length - 1);
-            } else {
-                local.append(inwd);
-            }
-            break;
-        case 'W' : /* looking for WR or WH */
-            if (inwd[1] == 'R') {   // WR -> R
-                local.append(inwd, 1, inwd.length - 1); 
-                break ;
-            }
-            if (inwd[1] == 'H') {
-                local.append(inwd, 1, inwd.length - 1);
-                local.setCharAt(0, 'W'); // WH -> W
-            } else {
-                local.append(inwd);
-            }
-            break;
-        case 'X' : /* initial X becomes S */
-            inwd[0] = 'S';
-            local.append(inwd);
-            break ;
-        default :
-            local.append(inwd);
-        } // now local has working string with initials fixed
-
-        int wdsz = local.length();
-        int n = 0 ;
-
-        while ((code.length() < this.getMaxCodeLen()) && 
-               (n < wdsz) ) { // max code size of 4 works well
-            char symb = local.charAt(n) ;
-            // remove duplicate letters except C
-            if ((symb != 'C') && (isPreviousChar( local, n, symb )) ) {
-                n++ ;
-            } else { // not dup
-                switch(symb) {
-                case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
-                    if (n == 0) { 
-                        code.append(symb);
-                    }
-                    break ; // only use vowel if leading char
-                case 'B' :
-                    if ( isPreviousChar(local, n, 'M') && 
-                         isLastChar(wdsz, n) ) { // B is silent if word ends in MB
-                        break;
-                    }
-                    code.append(symb);
-                    break;
-                case 'C' : // lots of C special cases
-                    /* discard if SCI, SCE or SCY */
-                    if ( isPreviousChar(local, n, 'S') && 
-                         !isLastChar(wdsz, n) && 
-                         (FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) { 
-                        break;
-                    }
-                    if (regionMatch(local, n, "CIA")) { // "CIA" -> X
-                        code.append('X'); 
-                        break;
-                    }
-                    if (!isLastChar(wdsz, n) && 
-                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
-                        code.append('S');
-                        break; // CI,CE,CY -> S
-                    }
-                    if (isPreviousChar(local, n, 'S') &&
-                        isNextChar(local, n, 'H') ) { // SCH->sk
-                        code.append('K') ; 
-                        break ;
-                    }
-                    if (isNextChar(local, n, 'H')) { // detect CH
-                        if ((n == 0) && 
-                            (wdsz >= 3) && 
-                            isVowel(local,2) ) { // CH consonant -> K consonant
-                            code.append('K');
-                        } else { 
-                            code.append('X'); // CHvowel -> X
-                        }
-                    } else { 
-                        code.append('K');
-                    }
-                    break ;
-                case 'D' :
-                    if (!isLastChar(wdsz, n + 1) && 
-                        isNextChar(local, n, 'G') && 
-                        (FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { // DGE DGI DGY -> J 
-                        code.append('J'); n += 2 ;
-                    } else { 
-                        code.append('T');
-                    }
-                    break ;
-                case 'G' : // GH silent at end or before consonant
-                    if (isLastChar(wdsz, n + 1) && 
-                        isNextChar(local, n, 'H')) {
-                        break;
-                    }
-                    if (!isLastChar(wdsz, n + 1) &&  
-                        isNextChar(local,n,'H') && 
-                        !isVowel(local,n+2)) {
-                        break;
-                    }
-                    if ((n > 0) && 
-                        ( regionMatch(local, n, "GN") ||
-                          regionMatch(local, n, "GNED") ) ) {
-                        break; // silent G
-                    }
-                    if (isPreviousChar(local, n, 'G')) {
-                        // NOTE: Given that duplicated chars are removed, I don't see how this can ever be true
-                        hard = true ;
-                    } else {
-                        hard = false ;
-                    }
-                    if (!isLastChar(wdsz, n) && 
-                        (FRONTV.indexOf(local.charAt(n + 1)) >= 0) && 
-                        (!hard)) {
-                        code.append('J');
-                    } else {
-                        code.append('K');
-                    }
-                    break ;
-                case 'H':
-                    if (isLastChar(wdsz, n)) {
-                        break ; // terminal H
-                    }
-                    if ((n > 0) && 
-                        (VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
-                        break;
-                    }
-                    if (isVowel(local,n+1)) {
-                        code.append('H'); // Hvowel
-                    }
-                    break;
-                case 'F': 
-                case 'J' : 
-                case 'L' :
-                case 'M': 
-                case 'N' : 
-                case 'R' :
-                    code.append(symb); 
-                    break;
-                case 'K' :
-                    if (n > 0) { // not initial
-                        if (!isPreviousChar(local, n, 'C')) {
-                            code.append(symb);
-                        }
-                    } else {
-                        code.append(symb); // initial K
-                    }
-                    break ;
-                case 'P' :
-                    if (isNextChar(local,n,'H')) {
-                        // PH -> F
-                        code.append('F');
-                    } else {
-                        code.append(symb);
-                    }
-                    break ;
-                case 'Q' :
-                    code.append('K');
-                    break;
-                case 'S' :
-                    if (regionMatch(local,n,"SH") || 
-                        regionMatch(local,n,"SIO") || 
-                        regionMatch(local,n,"SIA")) {
-                        code.append('X');
-                    } else {
-                        code.append('S');
-                    }
-                    break;
-                case 'T' :
-                    if (regionMatch(local,n,"TIA") || 
-                        regionMatch(local,n,"TIO")) {
-                        code.append('X'); 
-                        break;
-                    }
-                    if (regionMatch(local,n,"TCH")) {
-                        // Silent if in "TCH"
-                        break;
-                    }
-                    // substitute numeral 0 for TH (resembles theta after all)
-                    if (regionMatch(local,n,"TH")) {
-                        code.append('0');
-                    } else {
-                        code.append('T');
-                    }
-                    break ;
-                case 'V' :
-                    code.append('F'); break ;
-                case 'W' : case 'Y' : // silent if not followed by vowel
-                    if (!isLastChar(wdsz,n) && 
-                        isVowel(local,n+1)) {
-                        code.append(symb);
-                    }
-                    break ;
-                case 'X' :
-                    code.append('K'); code.append('S');
-                    break ;
-                case 'Z' :
-                    code.append('S'); break ;
-                } // end switch
-                n++ ;
-            } // end else from symb != 'C'
-            if (code.length() > this.getMaxCodeLen()) { 
-                code.setLength(this.getMaxCodeLen()); 
-            }
-        }
-        return code.toString();
-    }
-
-    private boolean isVowel(StringBuffer string, int index) {
-        return VOWELS.indexOf(string.charAt(index)) >= 0;
-    }
-
-    private boolean isPreviousChar(StringBuffer string, int index, char c) {
-        boolean matches = false;
-        if( index > 0 &&
-            index < string.length() ) {
-            matches = string.charAt(index - 1) == c;
-        }
-        return matches;
-    }
-
-    private boolean isNextChar(StringBuffer string, int index, char c) {
-        boolean matches = false;
-        if( index >= 0 &&
-            index < string.length() - 1 ) {
-            matches = string.charAt(index + 1) == c;
-        }
-        return matches;
-    }
-
-    private boolean regionMatch(StringBuffer string, int index, String test) {
-        boolean matches = false;
-        if( index >= 0 &&
-            (index + test.length() - 1) < string.length() ) {
-            String substring = string.substring( index, index + test.length());
-            matches = substring.equals( test );
-        }
-        return matches;
-    }
-
-    private boolean isLastChar(int wdsz, int n) {
-        return n + 1 == wdsz;
-    } 
-    
-    
-    /**
-     * Encodes an Object using the metaphone algorithm.  This method
-     * is provided in order to satisfy the requirements of the
-     * Encoder interface, and will throw an EncoderException if the
-     * supplied object is not of type java.lang.String.
-     *
-     * @param pObject Object to encode
-     * @return An object (or type java.lang.String) containing the 
-     *         metaphone code which corresponds to the String supplied.
-     * @throws EncoderException if the parameter supplied is not
-     *                          of type java.lang.String
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (!(pObject instanceof String)) {
-            throw new EncoderException("Parameter supplied to Metaphone encode is not of type java.lang.String"); 
-        }
-        return metaphone((String) pObject);
-    }
-
-    /**
-     * Encodes a String using the Metaphone algorithm. 
-     *
-     * @param pString String object to encode
-     * @return The metaphone code corresponding to the String supplied
-     */
-    public String encode(String pString) {
-        return metaphone(pString);   
-    }
-
-    /**
-     * Tests is the metaphones of two strings are identical.
-     *
-     * @param str1 First of two strings to compare
-     * @param str2 Second of two strings to compare
-     * @return <code>true</code> if the metaphones of these strings are identical, 
-     *        <code>false</code> otherwise.
-     */
-    public boolean isMetaphoneEqual(String str1, String str2) {
-        return metaphone(str1).equals(metaphone(str2));
-    }
-
-    /**
-     * Returns the maxCodeLen.
-     * @return int
-     */
-    public int getMaxCodeLen() { return this.maxCodeLen; }
-
-    /**
-     * Sets the maxCodeLen.
-     * @param maxCodeLen The maxCodeLen to set
-     */
-    public void setMaxCodeLen(int maxCodeLen) { this.maxCodeLen = maxCodeLen; }
-
-}
diff -Nru old\org\apache\commons\codec\language\package.html new\org\apache\commons\codec\language\package.html
--- old\org\apache\commons\codec\language\package.html	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\package.html	Thu Jan 01 01:00:00 1970
@@ -1,21 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<html>
- <body>
-  Language and phonetic encoders.
- </body>
-</html>
diff -Nru old\org\apache\commons\codec\language\RefinedSoundex.java new\org\apache\commons\codec\language\RefinedSoundex.java
--- old\org\apache\commons\codec\language\RefinedSoundex.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\RefinedSoundex.java	Thu Jan 01 01:00:00 1970
@@ -1,202 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Encodes a string into a Refined Soundex value. A refined soundex code is
- * optimized for spell checking words. Soundex method originally developed by
- * <CITE>Margaret Odell</CITE> and <CITE>Robert Russell</CITE>.
- * 
- * @author Apache Software Foundation
- * @version $Id: RefinedSoundex.java 797690 2009-07-24 23:28:35Z ggregory $
- */
-public class RefinedSoundex implements StringEncoder {
-
-    /**
-     * @since 1.4
-     */
-    public static final String US_ENGLISH_MAPPING_STRING = "01360240043788015936020505";
-
-   /**
-     * RefinedSoundex is *refined* for a number of reasons one being that the
-     * mappings have been altered. This implementation contains default
-     * mappings for US English.
-     */
-    public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();
-
-    /**
-     * Every letter of the alphabet is "mapped" to a numerical value. This char
-     * array holds the values to which each letter is mapped. This
-     * implementation contains a default map for US_ENGLISH
-     */
-    private final char[] soundexMapping;
-
-    /**
-     * This static variable contains an instance of the RefinedSoundex using
-     * the US_ENGLISH mapping.
-     */
-    public static final RefinedSoundex US_ENGLISH = new RefinedSoundex();
-
-     /**
-     * Creates an instance of the RefinedSoundex object using the default US
-     * English mapping.
-     */
-    public RefinedSoundex() {
-        this.soundexMapping = US_ENGLISH_MAPPING;
-    }
-
-    /**
-     * Creates a refined soundex instance using a custom mapping. This
-     * constructor can be used to customize the mapping, and/or possibly
-     * provide an internationalized mapping for a non-Western character set.
-     * 
-     * @param mapping
-     *                  Mapping array to use when finding the corresponding code for
-     *                  a given character
-     */
-    public RefinedSoundex(char[] mapping) {
-        this.soundexMapping = new char[mapping.length];
-        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);
-    }
-
-    /**
-     * Creates a refined Soundex instance using a custom mapping. This constructor can be used to customize the mapping,
-     * and/or possibly provide an internationalized mapping for a non-Western character set.
-     * 
-     * @param mapping
-     *            Mapping string to use when finding the corresponding code for a given character
-     * @since 1.4
-     */
-    public RefinedSoundex(String mapping) {
-        this.soundexMapping = mapping.toCharArray();
-    }
-
-    /**
-     * Returns the number of characters in the two encoded Strings that are the
-     * same. This return value ranges from 0 to the length of the shortest
-     * encoded String: 0 indicates little or no similarity, and 4 out of 4 (for
-     * example) indicates strong similarity or identical values. For refined
-     * Soundex, the return value can be greater than 4.
-     * 
-     * @param s1
-     *                  A String that will be encoded and compared.
-     * @param s2
-     *                  A String that will be encoded and compared.
-     * @return The number of characters in the two encoded Strings that are the
-     *             same from 0 to to the length of the shortest encoded String.
-     * 
-     * @see SoundexUtils#difference(StringEncoder,String,String)
-     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">
-     *          MS T-SQL DIFFERENCE</a>
-     * 
-     * @throws EncoderException
-     *                  if an error occurs encoding one of the strings
-     * @since 1.3
-     */
-    public int difference(String s1, String s2) throws EncoderException {
-        return SoundexUtils.difference(this, s1, s2);
-    }
-
-    /**
-     * Encodes an Object using the refined soundex algorithm. This method is
-     * provided in order to satisfy the requirements of the Encoder interface,
-     * and will throw an EncoderException if the supplied object is not of type
-     * java.lang.String.
-     * 
-     * @param pObject
-     *                  Object to encode
-     * @return An object (or type java.lang.String) containing the refined
-     *             soundex code which corresponds to the String supplied.
-     * @throws EncoderException
-     *                  if the parameter supplied is not of type java.lang.String
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (!(pObject instanceof String)) {
-            throw new EncoderException("Parameter supplied to RefinedSoundex encode is not of type java.lang.String");
-        }
-        return soundex((String) pObject);
-    }
-
-    /**
-     * Encodes a String using the refined soundex algorithm.
-     * 
-     * @param pString
-     *                  A String object to encode
-     * @return A Soundex code corresponding to the String supplied
-     */
-    public String encode(String pString) {
-        return soundex(pString);
-    }
-
-    /**
-     * Returns the mapping code for a given character. The mapping codes are
-     * maintained in an internal char array named soundexMapping, and the
-     * default values of these mappings are US English.
-     * 
-     * @param c
-     *                  char to get mapping for
-     * @return A character (really a numeral) to return for the given char
-     */
-    char getMappingCode(char c) {
-        if (!Character.isLetter(c)) {
-            return 0;
-        }
-        return this.soundexMapping[Character.toUpperCase(c) - 'A'];
-    }
-
-    /**
-     * Retreives the Refined Soundex code for a given String object.
-     * 
-     * @param str
-     *                  String to encode using the Refined Soundex algorithm
-     * @return A soundex code for the String supplied
-     */
-    public String soundex(String str) {
-        if (str == null) {
-            return null;
-        }
-        str = SoundexUtils.clean(str);
-        if (str.length() == 0) {
-            return str;
-        }
-
-        StringBuffer sBuf = new StringBuffer();
-        sBuf.append(str.charAt(0));
-
-        char last, current;
-        last = '*';
-
-        for (int i = 0; i < str.length(); i++) {
-
-            current = getMappingCode(str.charAt(i));
-            if (current == last) {
-                continue;
-            } else if (current != 0) {
-                sBuf.append(current);
-            }
-
-            last = current;
-
-        }
-
-        return sBuf.toString();
-    }
-}
diff -Nru old\org\apache\commons\codec\language\Soundex.java new\org\apache\commons\codec\language\Soundex.java
--- old\org\apache\commons\codec\language\Soundex.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\Soundex.java	Thu Jan 01 01:00:00 1970
@@ -1,278 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Encodes a string into a Soundex value. Soundex is an encoding used to relate similar names, but can also be used as a
- * general purpose scheme to find word with similar phonemes.
- * 
- * @author Apache Software Foundation
- * @version $Id: Soundex.java 794026 2009-07-14 19:21:23Z ggregory $
- */
-public class Soundex implements StringEncoder {
-
-    /**
-     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position
-     * means do not encode.
-     * <p>
-     * (This constant is provided as both an implementation convenience and to allow Javadoc to pick
-     * up the value for the constant values page.)
-     * </p>
-     * 
-     * @see #US_ENGLISH_MAPPING
-     */
-    public static final String US_ENGLISH_MAPPING_STRING = "01230120022455012623010202";
-
-    /**
-     * This is a default mapping of the 26 letters used in US English. A value of <code>0</code> for a letter position
-     * means do not encode.
-     * 
-     * @see Soundex#Soundex(char[])
-     */
-    public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();
-
-    /**
-     * An instance of Soundex using the US_ENGLISH_MAPPING mapping.
-     * 
-     * @see #US_ENGLISH_MAPPING
-     */
-    public static final Soundex US_ENGLISH = new Soundex();
-
-
-    /**
-     * Encodes the Strings and returns the number of characters in the two encoded Strings that are the same. This
-     * return value ranges from 0 through 4: 0 indicates little or no similarity, and 4 indicates strong similarity or
-     * identical values.
-     * 
-     * @param s1
-     *                  A String that will be encoded and compared.
-     * @param s2
-     *                  A String that will be encoded and compared.
-     * @return The number of characters in the two encoded Strings that are the same from 0 to 4.
-     * 
-     * @see SoundexUtils#difference(StringEncoder,String,String)
-     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp"> MS
-     *          T-SQL DIFFERENCE </a>
-     * 
-     * @throws EncoderException
-     *                  if an error occurs encoding one of the strings
-     * @since 1.3
-     */
-    public int difference(String s1, String s2) throws EncoderException {
-        return SoundexUtils.difference(this, s1, s2);
-    }
-
-    /**
-     * The maximum length of a Soundex code - Soundex codes are only four characters by definition.
-     * 
-     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.
-     */
-    private int maxLength = 4;
-
-    /**
-     * Every letter of the alphabet is "mapped" to a numerical value. This char array holds the values to which each
-     * letter is mapped. This implementation contains a default map for US_ENGLISH
-     */
-    private final char[] soundexMapping;
-
-    /**
-     * Creates an instance using US_ENGLISH_MAPPING
-     * 
-     * @see Soundex#Soundex(char[])
-     * @see Soundex#US_ENGLISH_MAPPING
-     */
-    public Soundex() {
-        this.soundexMapping = US_ENGLISH_MAPPING;
-    }
-
-    /**
-     * Creates a soundex instance using the given mapping. This constructor can be used to provide an internationalized
-     * mapping for a non-Western character set.
-     * 
-     * Every letter of the alphabet is "mapped" to a numerical value. This char array holds the values to which each
-     * letter is mapped. This implementation contains a default map for US_ENGLISH
-     * 
-     * @param mapping
-     *                  Mapping array to use when finding the corresponding code for a given character
-     */
-    public Soundex(char[] mapping) {
-        this.soundexMapping = new char[mapping.length];
-        System.arraycopy(mapping, 0, this.soundexMapping, 0, mapping.length);
-    }
-
-    /**
-     * Creates a refined soundex instance using a custom mapping. This constructor can be used to customize the mapping,
-     * and/or possibly provide an internationalized mapping for a non-Western character set.
-     * 
-     * @param mapping
-     *            Mapping string to use when finding the corresponding code for a given character
-     * @since 1.4
-     */
-    public Soundex(String mapping) {
-        this.soundexMapping = mapping.toCharArray();
-    }
-
-    /**
-     * Encodes an Object using the soundex algorithm. This method is provided in order to satisfy the requirements of
-     * the Encoder interface, and will throw an EncoderException if the supplied object is not of type java.lang.String.
-     * 
-     * @param pObject
-     *                  Object to encode
-     * @return An object (or type java.lang.String) containing the soundex code which corresponds to the String
-     *             supplied.
-     * @throws EncoderException
-     *                  if the parameter supplied is not of type java.lang.String
-     * @throws IllegalArgumentException
-     *                  if a character is not mapped
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (!(pObject instanceof String)) {
-            throw new EncoderException("Parameter supplied to Soundex encode is not of type java.lang.String");
-        }
-        return soundex((String) pObject);
-    }
-
-    /**
-     * Encodes a String using the soundex algorithm.
-     * 
-     * @param pString
-     *                  A String object to encode
-     * @return A Soundex code corresponding to the String supplied
-     * @throws IllegalArgumentException
-     *                  if a character is not mapped
-     */
-    public String encode(String pString) {
-        return soundex(pString);
-    }
-
-    /**
-     * Used internally by the SoundEx algorithm.
-     * 
-     * Consonants from the same code group separated by W or H are treated as one.
-     * 
-     * @param str
-     *                  the cleaned working string to encode (in upper case).
-     * @param index
-     *                  the character position to encode
-     * @return Mapping code for a particular character
-     * @throws IllegalArgumentException
-     *                  if the character is not mapped
-     */
-    private char getMappingCode(String str, int index) {
-        // map() throws IllegalArgumentException
-        char mappedChar = this.map(str.charAt(index));
-        // HW rule check
-        if (index > 1 && mappedChar != '0') {
-            char hwChar = str.charAt(index - 1);
-            if ('H' == hwChar || 'W' == hwChar) {
-                char preHWChar = str.charAt(index - 2);
-                char firstCode = this.map(preHWChar);
-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {
-                    return 0;
-                }
-            }
-        }
-        return mappedChar;
-    }
-
-    /**
-     * Returns the maxLength. Standard Soundex
-     * 
-     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.
-     * @return int
-     */
-    public int getMaxLength() {
-        return this.maxLength;
-    }
-
-    /**
-     * Returns the soundex mapping.
-     * 
-     * @return soundexMapping.
-     */
-    private char[] getSoundexMapping() {
-        return this.soundexMapping;
-    }
-
-    /**
-     * Maps the given upper-case character to its Soundex code.
-     * 
-     * @param ch
-     *                  An upper-case character.
-     * @return A Soundex code.
-     * @throws IllegalArgumentException
-     *                  Thrown if <code>ch</code> is not mapped.
-     */
-    private char map(char ch) {
-        int index = ch - 'A';
-        if (index < 0 || index >= this.getSoundexMapping().length) {
-            throw new IllegalArgumentException("The character is not mapped: " + ch);
-        }
-        return this.getSoundexMapping()[index];
-    }
-
-    /**
-     * Sets the maxLength.
-     * 
-     * @deprecated This feature is not needed since the encoding size must be constant. Will be removed in 2.0.
-     * @param maxLength
-     *                  The maxLength to set
-     */
-    public void setMaxLength(int maxLength) {
-        this.maxLength = maxLength;
-    }
-
-    /**
-     * Retrieves the Soundex code for a given String object.
-     * 
-     * @param str
-     *                  String to encode using the Soundex algorithm
-     * @return A soundex code for the String supplied
-     * @throws IllegalArgumentException
-     *                  if a character is not mapped
-     */
-    public String soundex(String str) {
-        if (str == null) {
-            return null;
-        }
-        str = SoundexUtils.clean(str);
-        if (str.length() == 0) {
-            return str;
-        }
-        char out[] = {'0', '0', '0', '0'};
-        char last, mapped;
-        int incount = 1, count = 1;
-        out[0] = str.charAt(0);
-        // getMappingCode() throws IllegalArgumentException
-        last = getMappingCode(str, 0);
-        while ((incount < str.length()) && (count < out.length)) {
-            mapped = getMappingCode(str, incount++);
-            if (mapped != 0) {
-                if ((mapped != '0') && (mapped != last)) {
-                    out[count++] = mapped;
-                }
-                last = mapped;
-            }
-        }
-        return new String(out);
-    }
-
-}
diff -Nru old\org\apache\commons\codec\language\SoundexUtils.java new\org\apache\commons\codec\language\SoundexUtils.java
--- old\org\apache\commons\codec\language\SoundexUtils.java	Thu Aug 06 17:40:28 2009
+++ new\org\apache\commons\codec\language\SoundexUtils.java	Thu Jan 01 01:00:00 1970
@@ -1,123 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.language;
-
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * Utility methods for {@link Soundex} and {@link RefinedSoundex} classes.
- * 
- * @author Apache Software Foundation
- * @version $Id: SoundexUtils.java 658834 2008-05-21 19:57:51Z niallp $
- * @since 1.3
- */
-final class SoundexUtils {
-
-    /**
-     * Cleans up the input string before Soundex processing by only returning
-     * upper case letters.
-     * 
-     * @param str
-     *                  The String to clean.
-     * @return A clean String.
-     */
-    static String clean(String str) {
-        if (str == null || str.length() == 0) {
-            return str;
-        }
-        int len = str.length();
-        char[] chars = new char[len];
-        int count = 0;
-        for (int i = 0; i < len; i++) {
-            if (Character.isLetter(str.charAt(i))) {
-                chars[count++] = str.charAt(i);
-            }
-        }
-        if (count == len) {
-            return str.toUpperCase(java.util.Locale.ENGLISH);
-        }
-        return new String(chars, 0, count).toUpperCase(java.util.Locale.ENGLISH);
-    }
-
-    /**
-     * Encodes the Strings and returns the number of characters in the two
-     * encoded Strings that are the same.
-     * <ul>
-     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates
-     * little or no similarity, and 4 indicates strong similarity or identical
-     * values.</li>
-     * <li>For refined Soundex, the return value can be greater than 4.</li>
-     * </ul>
-     * 
-     * @param encoder
-     *                  The encoder to use to encode the Strings.
-     * @param s1
-     *                  A String that will be encoded and compared.
-     * @param s2
-     *                  A String that will be encoded and compared.
-     * @return The number of characters in the two Soundex encoded Strings that
-     *             are the same.
-     * 
-     * @see #differenceEncoded(String,String)
-     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">
-     *          MS T-SQL DIFFERENCE</a>
-     * 
-     * @throws EncoderException
-     *                  if an error occurs encoding one of the strings
-     */
-    static int difference(StringEncoder encoder, String s1, String s2) throws EncoderException {
-        return differenceEncoded(encoder.encode(s1), encoder.encode(s2));
-    }
-
-    /**
-     * Returns the number of characters in the two Soundex encoded Strings that
-     * are the same.
-     * <ul>
-     * <li>For Soundex, this return value ranges from 0 through 4: 0 indicates
-     * little or no similarity, and 4 indicates strong similarity or identical
-     * values.</li>
-     * <li>For refined Soundex, the return value can be greater than 4.</li>
-     * </ul>
-     * 
-     * @param es1
-     *                  An encoded String.
-     * @param es2
-     *                  An encoded String.
-     * @return The number of characters in the two Soundex encoded Strings that
-     *             are the same.
-     * 
-     * @see <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_de-dz_8co5.asp">
-     *          MS T-SQL DIFFERENCE</a>
-     */
-    static int differenceEncoded(String es1, String es2) {
-
-        if (es1 == null || es2 == null) {
-            return 0;
-        }
-        int lengthToMatch = Math.min(es1.length(), es2.length());
-        int diff = 0;
-        for (int i = 0; i < lengthToMatch; i++) {
-            if (es1.charAt(i) == es2.charAt(i)) {
-                diff++;
-            }
-        }
-        return diff;
-    }
-
-}
diff -Nru old\org\apache\commons\codec\net\BCodec.java new\org\apache\commons\codec\net\BCodec.java
--- old\org\apache\commons\codec\net\BCodec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\BCodec.java	Thu Jan 01 01:00:00 1970
@@ -1,208 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.CharEncoding;
-import org.apache.commons.codec.StringDecoder;
-import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.Base64;
-
-/**
- * <p>
- * Identical to the Base64 encoding defined by <a href="http://www.ietf.org/rfc/rfc1521.txt">RFC
- * 1521</a> and allows a character set to be specified.
- * </p>
- * 
- * <p>
- * <a href="http://www.ietf.org/rfc/rfc1522.txt">RFC 1522</a> describes techniques to allow the encoding of non-ASCII
- * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message
- * handling software.
- * </p>
- * 
- * @see <a href="http://www.ietf.org/rfc/rfc1522.txt">MIME (Multipurpose Internet Mail Extensions) Part Two: Message
- *          Header Extensions for Non-ASCII Text</a>
- * 
- * @author Apache Software Foundation
- * @since 1.3
- * @version $Id: BCodec.java 797857 2009-07-25 23:43:33Z ggregory $
- */
-public class BCodec extends RFC1522Codec implements StringEncoder, StringDecoder {
-    /**
-     * The default charset used for string decoding and encoding.
-     */
-    private final String charset;
-
-    /**
-     * Default constructor.
-     */
-    public BCodec() {
-        this(CharEncoding.UTF_8);
-    }
-
-    /**
-     * Constructor which allows for the selection of a default charset
-     * 
-     * @param charset
-     *                  the default string charset to use.
-     * 
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     */
-    public BCodec(final String charset) {
-        super();
-        this.charset = charset;
-    }
-
-    protected String getEncoding() {
-        return "B";
-    }
-
-    protected byte[] doEncoding(byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        return Base64.encodeBase64(bytes);
-    }
-
-    protected byte[] doDecoding(byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        return Base64.decodeBase64(bytes);
-    }
-
-    /**
-     * Encodes a string into its Base64 form using the specified charset. Unsafe characters are escaped.
-     * 
-     * @param value
-     *                  string to convert to Base64 form
-     * @param charset
-     *                  the charset for <code>value</code>
-     * @return Base64 string
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public String encode(final String value, final String charset) throws EncoderException {
-        if (value == null) {
-            return null;
-        }
-        try {
-            return encodeText(value, charset);
-        } catch (UnsupportedEncodingException e) {
-            throw new EncoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes a string into its Base64 form using the default charset. Unsafe characters are escaped.
-     * 
-     * @param value
-     *                  string to convert to Base64 form
-     * @return Base64 string
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public String encode(String value) throws EncoderException {
-        if (value == null) {
-            return null;
-        }
-        return encode(value, getDefaultCharset());
-    }
-
-    /**
-     * Decodes a Base64 string into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param value
-     *            Base64 string to convert into its original form
-     * @return original string
-     * @throws DecoderException
-     *             A decoder exception is thrown if a failure condition is encountered during the decode process.
-     */
-    public String decode(String value) throws DecoderException {
-        if (value == null) {
-            return null;
-        }
-        try {
-            return decodeText(value);
-        } catch (UnsupportedEncodingException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes an object into its Base64 form using the default charset. Unsafe characters are escaped.
-     * 
-     * @param value
-     *                  object to convert to Base64 form
-     * @return Base64 object
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public Object encode(Object value) throws EncoderException {
-        if (value == null) {
-            return null;
-        } else if (value instanceof String) {
-            return encode((String) value);
-        } else {
-            throw new EncoderException("Objects of type " +
-                  value.getClass().getName() +
-                  " cannot be encoded using BCodec");
-        }
-    }
-
-    /**
-     * Decodes a Base64 object into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param value
-     *                  Base64 object to convert into its original form
-     * 
-     * @return original object
-     * 
-     * @throws DecoderException
-     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is
-     *                  encountered during the decode process.
-     */
-    public Object decode(Object value) throws DecoderException {
-        if (value == null) {
-            return null;
-        } else if (value instanceof String) {
-            return decode((String) value);
-        } else {
-            throw new DecoderException("Objects of type " +
-                  value.getClass().getName() +
-                  " cannot be decoded using BCodec");
-        }
-    }
-
-    /**
-     * The default charset used for string decoding and encoding.
-     * 
-     * @return the default string charset.
-     */
-    public String getDefaultCharset() {
-        return this.charset;
-    }
-}
diff -Nru old\org\apache\commons\codec\net\package.html new\org\apache\commons\codec\net\package.html
--- old\org\apache\commons\codec\net\package.html	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\package.html	Thu Jan 01 01:00:00 1970
@@ -1,23 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<html>
- <body>
-  <p>
-  Network related encoding and decoding.
-  </p>
- </body>
-</html>
diff -Nru old\org\apache\commons\codec\net\QCodec.java new\org\apache\commons\codec\net\QCodec.java
--- old\org\apache\commons\codec\net\QCodec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\QCodec.java	Thu Jan 01 01:00:00 1970
@@ -1,311 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import java.io.UnsupportedEncodingException;
-import java.util.BitSet;
-
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.CharEncoding;
-import org.apache.commons.codec.StringDecoder;
-import org.apache.commons.codec.StringEncoder;
-
-/**
- * <p>
- * Similar to the Quoted-Printable content-transfer-encoding defined in <a
- * href="http://www.ietf.org/rfc/rfc1521.txt">RFC 1521</a> and designed to allow text containing mostly ASCII
- * characters to be decipherable on an ASCII terminal without decoding.
- * </p>
- * 
- * <p>
- * <a href="http://www.ietf.org/rfc/rfc1522.txt">RFC 1522</a> describes techniques to allow the encoding of non-ASCII
- * text in various portions of a RFC 822 [2] message header, in a manner which is unlikely to confuse existing message
- * handling software.
- * </p>
- * 
- * @see <a href="http://www.ietf.org/rfc/rfc1522.txt">MIME (Multipurpose Internet Mail Extensions) Part Two: Message
- *          Header Extensions for Non-ASCII Text</a>
- * 
- * @author Apache Software Foundation
- * @since 1.3
- * @version $Id: QCodec.java 797857 2009-07-25 23:43:33Z ggregory $
- */
-public class QCodec extends RFC1522Codec implements StringEncoder, StringDecoder {
-    /**
-     * The default charset used for string decoding and encoding.
-     */
-    private final String charset;
-
-    /**
-     * BitSet of printable characters as defined in RFC 1522.
-     */
-    private static final BitSet PRINTABLE_CHARS = new BitSet(256);
-    // Static initializer for printable chars collection
-    static {
-        // alpha characters
-        PRINTABLE_CHARS.set(' ');
-        PRINTABLE_CHARS.set('!');
-        PRINTABLE_CHARS.set('"');
-        PRINTABLE_CHARS.set('#');
-        PRINTABLE_CHARS.set('$');
-        PRINTABLE_CHARS.set('%');
-        PRINTABLE_CHARS.set('&');
-        PRINTABLE_CHARS.set('\'');
-        PRINTABLE_CHARS.set('(');
-        PRINTABLE_CHARS.set(')');
-        PRINTABLE_CHARS.set('*');
-        PRINTABLE_CHARS.set('+');
-        PRINTABLE_CHARS.set(',');
-        PRINTABLE_CHARS.set('-');
-        PRINTABLE_CHARS.set('.');
-        PRINTABLE_CHARS.set('/');
-        for (int i = '0'; i <= '9'; i++) {
-            PRINTABLE_CHARS.set(i);
-        }
-        PRINTABLE_CHARS.set(':');
-        PRINTABLE_CHARS.set(';');
-        PRINTABLE_CHARS.set('<');
-        PRINTABLE_CHARS.set('>');
-        PRINTABLE_CHARS.set('@');
-        for (int i = 'A'; i <= 'Z'; i++) {
-            PRINTABLE_CHARS.set(i);
-        }
-        PRINTABLE_CHARS.set('[');
-        PRINTABLE_CHARS.set('\\');
-        PRINTABLE_CHARS.set(']');
-        PRINTABLE_CHARS.set('^');
-        PRINTABLE_CHARS.set('`');
-        for (int i = 'a'; i <= 'z'; i++) {
-            PRINTABLE_CHARS.set(i);
-        }
-        PRINTABLE_CHARS.set('{');
-        PRINTABLE_CHARS.set('|');
-        PRINTABLE_CHARS.set('}');
-        PRINTABLE_CHARS.set('~');
-    }
-
-    private static final byte BLANK = 32;
-
-    private static final byte UNDERSCORE = 95;
-
-    private boolean encodeBlanks = false;
-
-    /**
-     * Default constructor.
-     */
-    public QCodec() {
-        this(CharEncoding.UTF_8);
-    }
-
-    /**
-     * Constructor which allows for the selection of a default charset
-     * 
-     * @param charset
-     *                  the default string charset to use.
-     * 
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     */
-    public QCodec(final String charset) {
-        super();
-        this.charset = charset;
-    }
-
-    protected String getEncoding() {
-        return "Q";
-    }
-
-    protected byte[] doEncoding(byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        byte[] data = QuotedPrintableCodec.encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
-        if (this.encodeBlanks) {
-            for (int i = 0; i < data.length; i++) {
-                if (data[i] == BLANK) {
-                    data[i] = UNDERSCORE;
-                }
-            }
-        }
-        return data;
-    }
-
-    protected byte[] doDecoding(byte[] bytes) throws DecoderException {
-        if (bytes == null) {
-            return null;
-        }
-        boolean hasUnderscores = false;
-        for (int i = 0; i < bytes.length; i++) {
-            if (bytes[i] == UNDERSCORE) {
-                hasUnderscores = true;
-                break;
-            }
-        }
-        if (hasUnderscores) {
-            byte[] tmp = new byte[bytes.length];
-            for (int i = 0; i < bytes.length; i++) {
-                byte b = bytes[i];
-                if (b != UNDERSCORE) {
-                    tmp[i] = b;
-                } else {
-                    tmp[i] = BLANK;
-                }
-            }
-            return QuotedPrintableCodec.decodeQuotedPrintable(tmp);
-        } 
-        return QuotedPrintableCodec.decodeQuotedPrintable(bytes);       
-    }
-
-    /**
-     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.
-     * 
-     * @param pString
-     *                  string to convert to quoted-printable form
-     * @param charset
-     *                  the charset for pString
-     * @return quoted-printable string
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public String encode(final String pString, final String charset) throws EncoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return encodeText(pString, charset);
-        } catch (UnsupportedEncodingException e) {
-            throw new EncoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes a string into its quoted-printable form using the default charset. Unsafe characters are escaped.
-     * 
-     * @param pString
-     *                  string to convert to quoted-printable form
-     * @return quoted-printable string
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public String encode(String pString) throws EncoderException {
-        if (pString == null) {
-            return null;
-        }
-        return encode(pString, getDefaultCharset());
-    }
-
-    /**
-     * Decodes a quoted-printable string into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param pString
-     *                  quoted-printable string to convert into its original form
-     * 
-     * @return original string
-     * 
-     * @throws DecoderException
-     *                  A decoder exception is thrown if a failure condition is encountered during the decode process.
-     */
-    public String decode(String pString) throws DecoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return decodeText(pString);
-        } catch (UnsupportedEncodingException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes an object into its quoted-printable form using the default charset. Unsafe characters are escaped.
-     * 
-     * @param pObject
-     *                  object to convert to quoted-printable form
-     * @return quoted-printable object
-     * 
-     * @throws EncoderException
-     *                  thrown if a failure condition is encountered during the encoding process.
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof String) {
-            return encode((String) pObject);
-        } else {
-            throw new EncoderException("Objects of type " + 
-                  pObject.getClass().getName() + 
-                  " cannot be encoded using Q codec");
-        }
-    }
-
-    /**
-     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param pObject
-     *                  quoted-printable object to convert into its original form
-     * 
-     * @return original object
-     * 
-     * @throws DecoderException
-     *                  Thrown if the argument is not a <code>String</code>. Thrown if a failure condition is
-     *                  encountered during the decode process.
-     */
-    public Object decode(Object pObject) throws DecoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof String) {
-            return decode((String) pObject);
-        } else {
-            throw new DecoderException("Objects of type " + 
-                  pObject.getClass().getName() + 
-                  " cannot be decoded using Q codec");
-        }
-    }
-
-    /**
-     * The default charset used for string decoding and encoding.
-     * 
-     * @return the default string charset.
-     */
-    public String getDefaultCharset() {
-        return this.charset;
-    }
-
-    /**
-     * Tests if optional tranformation of SPACE characters is to be used
-     * 
-     * @return <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise
-     */
-    public boolean isEncodeBlanks() {
-        return this.encodeBlanks;
-    }
-
-    /**
-     * Defines whether optional tranformation of SPACE characters is to be used
-     * 
-     * @param b
-     *                  <code>true</code> if SPACE characters are to be transformed, <code>false</code> otherwise
-     */
-    public void setEncodeBlanks(boolean b) {
-        this.encodeBlanks = b;
-    }
-}
diff -Nru old\org\apache\commons\codec\net\QuotedPrintableCodec.java new\org\apache\commons\codec\net\QuotedPrintableCodec.java
--- old\org\apache\commons\codec\net\QuotedPrintableCodec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\QuotedPrintableCodec.java	Thu Jan 01 01:00:00 1970
@@ -1,387 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import java.io.ByteArrayOutputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.BitSet;
-
-import org.apache.commons.codec.BinaryDecoder;
-import org.apache.commons.codec.BinaryEncoder;
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.CharEncoding;
-import org.apache.commons.codec.StringDecoder;
-import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringUtils;
-
-/**
- * <p>
- * Codec for the Quoted-Printable section of <a href="http://www.ietf.org/rfc/rfc1521.txt">RFC 1521 </a>.
- * </p>
- * <p>
- * The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to
- * printable characters in the ASCII character set. It encodes the data in such a way that the resulting octets are
- * unlikely to be modified by mail transport. If the data being encoded are mostly ASCII text, the encoded form of the
- * data remains largely recognizable by humans. A body which is entirely ASCII may also be encoded in Quoted-Printable
- * to ensure the integrity of the data should the message pass through a character- translating, and/or line-wrapping
- * gateway.
- * </p>
- * 
- * <p>
- * Note:
- * </p>
- * <p>
- * Rules #3, #4, and #5 of the quoted-printable spec are not implemented yet because the complete quoted-printable spec
- * does not lend itself well into the byte[] oriented codec framework. Complete the codec once the steamable codec
- * framework is ready. The motivation behind providing the codec in a partial form is that it can already come in handy
- * for those applications that do not require quoted-printable line formatting (rules #3, #4, #5), for instance Q codec.
- * </p>
- * 
- * @see <a href="http://www.ietf.org/rfc/rfc1521.txt"> RFC 1521 MIME (Multipurpose Internet Mail Extensions) Part One:
- *          Mechanisms for Specifying and Describing the Format of Internet Message Bodies </a>
- * 
- * @author Apache Software Foundation
- * @since 1.3
- * @version $Id: QuotedPrintableCodec.java 798333 2009-07-27 23:41:58Z ggregory $
- */
-public class QuotedPrintableCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {
-    /**
-     * The default charset used for string decoding and encoding.
-     */
-    private final String charset;
-
-    /**
-     * BitSet of printable characters as defined in RFC 1521.
-     */
-    private static final BitSet PRINTABLE_CHARS = new BitSet(256);
-
-    private static final byte ESCAPE_CHAR = '=';
-
-    private static final byte TAB = 9;
-
-    private static final byte SPACE = 32;
-    // Static initializer for printable chars collection
-    static {
-        // alpha characters
-        for (int i = 33; i <= 60; i++) {
-            PRINTABLE_CHARS.set(i);
-        }
-        for (int i = 62; i <= 126; i++) {
-            PRINTABLE_CHARS.set(i);
-        }
-        PRINTABLE_CHARS.set(TAB);
-        PRINTABLE_CHARS.set(SPACE);
-    }
-
-    /**
-     * Default constructor.
-     */
-    public QuotedPrintableCodec() {
-        this(CharEncoding.UTF_8);
-    }
-
-    /**
-     * Constructor which allows for the selection of a default charset
-     * 
-     * @param charset
-     *                  the default string charset to use.
-     */
-    public QuotedPrintableCodec(String charset) {
-        super();
-        this.charset = charset;
-    }
-
-    /**
-     * Encodes byte into its quoted-printable representation.
-     * 
-     * @param b
-     *                  byte to encode
-     * @param buffer
-     *                  the buffer to write to
-     */
-    private static final void encodeQuotedPrintable(int b, ByteArrayOutputStream buffer) {
-        buffer.write(ESCAPE_CHAR);
-        char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, 16));
-        char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, 16));
-        buffer.write(hex1);
-        buffer.write(hex2);
-    }
-
-    /**
-     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521 and is suitable for encoding binary data and unformatted text.
-     * </p>
-     * 
-     * @param printable
-     *                  bitset of characters deemed quoted-printable
-     * @param bytes
-     *                  array of bytes to be encoded
-     * @return array of bytes containing quoted-printable data
-     */
-    public static final byte[] encodeQuotedPrintable(BitSet printable, byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        if (printable == null) {
-            printable = PRINTABLE_CHARS;
-        }
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        for (int i = 0; i < bytes.length; i++) {
-            int b = bytes[i];
-            if (b < 0) {
-                b = 256 + b;
-            }
-            if (printable.get(b)) {
-                buffer.write(b);
-            } else {
-                encodeQuotedPrintable(b, buffer);
-            }
-        }
-        return buffer.toByteArray();
-    }
-
-    /**
-     * Decodes an array quoted-printable characters into an array of original bytes. Escaped characters are converted
-     * back to their original representation.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521.
-     * </p>
-     * 
-     * @param bytes
-     *                  array of quoted-printable characters
-     * @return array of original bytes
-     * @throws DecoderException
-     *                  Thrown if quoted-printable decoding is unsuccessful
-     */
-    public static final byte[] decodeQuotedPrintable(byte[] bytes) throws DecoderException {
-        if (bytes == null) {
-            return null;
-        }
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        for (int i = 0; i < bytes.length; i++) {
-            int b = bytes[i];
-            if (b == ESCAPE_CHAR) {
-                try {
-                    int u = Utils.digit16(bytes[++i]);
-                    int l = Utils.digit16(bytes[++i]);
-                    buffer.write((char) ((u << 4) + l));
-                } catch (ArrayIndexOutOfBoundsException e) {
-                    throw new DecoderException("Invalid quoted-printable encoding", e);
-                }
-            } else {
-                buffer.write(b);
-            }
-        }
-        return buffer.toByteArray();
-    }
-
-    /**
-     * Encodes an array of bytes into an array of quoted-printable 7-bit characters. Unsafe characters are escaped.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521 and is suitable for encoding binary data and unformatted text.
-     * </p>
-     * 
-     * @param bytes
-     *                  array of bytes to be encoded
-     * @return array of bytes containing quoted-printable data
-     */
-    public byte[] encode(byte[] bytes) {
-        return encodeQuotedPrintable(PRINTABLE_CHARS, bytes);
-    }
-
-    /**
-     * Decodes an array of quoted-printable characters into an array of original bytes. Escaped characters are converted
-     * back to their original representation.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521.
-     * </p>
-     * 
-     * @param bytes
-     *                  array of quoted-printable characters
-     * @return array of original bytes
-     * @throws DecoderException
-     *                  Thrown if quoted-printable decoding is unsuccessful
-     */
-    public byte[] decode(byte[] bytes) throws DecoderException {
-        return decodeQuotedPrintable(bytes);
-    }
-
-    /**
-     * Encodes a string into its quoted-printable form using the default string charset. Unsafe characters are escaped.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521 and is suitable for encoding binary data.
-     * </p>
-     * 
-     * @param pString
-     *                  string to convert to quoted-printable form
-     * @return quoted-printable string
-     * 
-     * @throws EncoderException
-     *                  Thrown if quoted-printable encoding is unsuccessful
-     * 
-     * @see #getDefaultCharset()
-     */
-    public String encode(String pString) throws EncoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return encode(pString, getDefaultCharset());
-        } catch (UnsupportedEncodingException e) {
-            throw new EncoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Decodes a quoted-printable string into its original form using the specified string charset. Escaped characters
-     * are converted back to their original representation.
-     * 
-     * @param pString
-     *                  quoted-printable string to convert into its original form
-     * @param charset
-     *                  the original string charset
-     * @return original string
-     * @throws DecoderException
-     *                  Thrown if quoted-printable decoding is unsuccessful
-     * @throws UnsupportedEncodingException
-     *                  Thrown if charset is not supported
-     */
-    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {
-        if (pString == null) {
-            return null;
-        }
-        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
-    }
-
-    /**
-     * Decodes a quoted-printable string into its original form using the default string charset. Escaped characters are
-     * converted back to their original representation.
-     * 
-     * @param pString
-     *                  quoted-printable string to convert into its original form
-     * @return original string
-     * @throws DecoderException
-     *                  Thrown if quoted-printable decoding is unsuccessful.
-     *                  Thrown if charset is not supported.
-     * @see #getDefaultCharset()
-     */
-    public String decode(String pString) throws DecoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return decode(pString, getDefaultCharset());
-        } catch (UnsupportedEncodingException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes an object into its quoted-printable safe form. Unsafe characters are escaped.
-     * 
-     * @param pObject
-     *                  string to convert to a quoted-printable form
-     * @return quoted-printable object
-     * @throws EncoderException
-     *                  Thrown if quoted-printable encoding is not applicable to objects of this type or if encoding is
-     *                  unsuccessful
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof byte[]) {
-            return encode((byte[]) pObject);
-        } else if (pObject instanceof String) {
-            return encode((String) pObject);
-        } else {
-            throw new EncoderException("Objects of type " + 
-                  pObject.getClass().getName() + 
-                  " cannot be quoted-printable encoded");
-        }
-    }
-
-    /**
-     * Decodes a quoted-printable object into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param pObject
-     *                  quoted-printable object to convert into its original form
-     * @return original object
-     * @throws DecoderException
-     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is
-     *                  encountered during the decode process.
-     */
-    public Object decode(Object pObject) throws DecoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof byte[]) {
-            return decode((byte[]) pObject);
-        } else if (pObject instanceof String) {
-            return decode((String) pObject);
-        } else {
-            throw new DecoderException("Objects of type " + 
-                  pObject.getClass().getName() + 
-                  " cannot be quoted-printable decoded");
-        }
-    }
-
-    /**
-     * Returns the default charset used for string decoding and encoding.
-     * 
-     * @return the default string charset.
-     */
-    public String getDefaultCharset() {
-        return this.charset;
-    }
-
-    /**
-     * Encodes a string into its quoted-printable form using the specified charset. Unsafe characters are escaped.
-     * 
-     * <p>
-     * This function implements a subset of quoted-printable encoding specification (rule #1 and rule #2) as defined in
-     * RFC 1521 and is suitable for encoding binary data and unformatted text.
-     * </p>
-     * 
-     * @param pString
-     *                  string to convert to quoted-printable form
-     * @param charset
-     *                  the charset for pString
-     * @return quoted-printable string
-     * 
-     * @throws UnsupportedEncodingException
-     *                  Thrown if the charset is not supported
-     */
-    public String encode(String pString, String charset) throws UnsupportedEncodingException {
-        if (pString == null) {
-            return null;
-        }
-        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
-    }
-}
diff -Nru old\org\apache\commons\codec\net\RFC1522Codec.java new\org\apache\commons\codec\net\RFC1522Codec.java
--- old\org\apache\commons\codec\net\RFC1522Codec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\RFC1522Codec.java	Thu Jan 01 01:00:00 1970
@@ -1,178 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import java.io.UnsupportedEncodingException;
-
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.binary.StringUtils;
-
-/**
- * <p>
- * Implements methods common to all codecs defined in RFC 1522.
- * </p>
- * 
- * <p>
- * <a href="http://www.ietf.org/rfc/rfc1522.txt">RFC 1522</a> 
- * describes techniques to allow the encoding of non-ASCII text in 
- * various portions of a RFC 822 [2] message header, in a manner which
- * is unlikely to confuse existing message handling software.
- * </p>
-
- * @see <a href="http://www.ietf.org/rfc/rfc1522.txt">
- * MIME (Multipurpose Internet Mail Extensions) Part Two:
- * Message Header Extensions for Non-ASCII Text</a>
- * </p>
- * 
- * @author Apache Software Foundation
- * @since 1.3
- * @version $Id: RFC1522Codec.java 798428 2009-07-28 07:32:49Z ggregory $
- */
-abstract class RFC1522Codec {
-    
-    /**
-     * Separator.
-     */
-    protected static final char SEP = '?';
-
-    /**
-     * Prefix
-     */
-    protected static final String POSTFIX = "?=";
-
-    /**
-     * Postfix
-     */
-    protected static final String PREFIX = "=?";
-
-    /**
-     * Applies an RFC 1522 compliant encoding scheme to the given string of text with the 
-     * given charset. This method constructs the "encoded-word" header common to all the 
-     * RFC 1522 codecs and then invokes {@link #doEncoding(byte [])} method of a concrete 
-     * class to perform the specific enconding.
-     * 
-     * @param text a string to encode
-     * @param charset a charset to be used
-     * 
-     * @return RFC 1522 compliant "encoded-word"
-     * 
-     * @throws EncoderException thrown if there is an error conidition during the Encoding 
-     *  process.
-     * @throws UnsupportedEncodingException thrown if charset is not supported 
-     * 
-     * @see <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/nio/charset/Charset.html">Standard charsets</a>
-     */
-    protected String encodeText(final String text, final String charset)
-     throws EncoderException, UnsupportedEncodingException  
-    {
-        if (text == null) {
-            return null;
-        }
-        StringBuffer buffer = new StringBuffer();
-        buffer.append(PREFIX); 
-        buffer.append(charset);
-        buffer.append(SEP);
-        buffer.append(getEncoding());
-        buffer.append(SEP);
-        byte [] rawdata = doEncoding(text.getBytes(charset)); 
-        buffer.append(StringUtils.newStringUsAscii(rawdata));
-        buffer.append(POSTFIX); 
-        return buffer.toString();
-    }
-    
-    /**
-     * Applies an RFC 1522 compliant decoding scheme to the given string of text. This method 
-     * processes the "encoded-word" header common to all the RFC 1522 codecs and then invokes 
-     * {@link #doEncoding(byte [])} method of a concrete class to perform the specific deconding.
-     * 
-     * @param text a string to decode
-     * @return A new decoded String or <code>null</code> if the input is <code>null</code>.
-     * 
-     * @throws DecoderException thrown if there is an error conidition during the Decoding 
-     *  process.
-     * @throws UnsupportedEncodingException thrown if charset specified in the "encoded-word" 
-     *  header is not supported 
-     */
-    protected String decodeText(final String text)
-     throws DecoderException, UnsupportedEncodingException  
-    {
-        if (text == null) {
-            return null;
-        }
-        if ((!text.startsWith(PREFIX)) || (!text.endsWith(POSTFIX))) {
-            throw new DecoderException("RFC 1522 violation: malformed encoded content");
-        }
-        int terminator = text.length() - 2;
-        int from = 2;
-        int to = text.indexOf(SEP, from);
-        if (to == terminator) {
-            throw new DecoderException("RFC 1522 violation: charset token not found");
-        }
-        String charset = text.substring(from, to);
-        if (charset.equals("")) {
-            throw new DecoderException("RFC 1522 violation: charset not specified");
-        }
-        from = to + 1;
-        to = text.indexOf(SEP, from);
-        if (to == terminator) {
-            throw new DecoderException("RFC 1522 violation: encoding token not found");
-        }
-        String encoding = text.substring(from, to);
-        if (!getEncoding().equalsIgnoreCase(encoding)) {
-            throw new DecoderException("This codec cannot decode " + 
-                encoding + " encoded content");
-        }
-        from = to + 1;
-        to = text.indexOf(SEP, from);
-        byte[] data = StringUtils.getBytesUsAscii(text.substring(from, to));
-        data = doDecoding(data); 
-        return new String(data, charset);
-    }
-
-    /**
-     * Returns the codec name (referred to as encoding in the RFC 1522)
-     * 
-     * @return name of the codec
-     */    
-    protected abstract String getEncoding();
-
-    /**
-     * Encodes an array of bytes using the defined encoding scheme
-     * 
-     * @param bytes Data to be encoded
-     *
-     * @return A byte array containing the encoded data
-     * 
-     * @throws EncoderException thrown if the Encoder encounters a failure condition 
-     *  during the encoding process.
-     */    
-    protected abstract byte[] doEncoding(byte[] bytes) throws EncoderException;
-
-    /**
-     * Decodes an array of bytes using the defined encoding scheme
-     * 
-     * @param bytes Data to be decoded
-     *
-     * @return a byte array that contains decoded data
-     * 
-     * @throws DecoderException A decoder exception is thrown if a Decoder encounters a 
-     *  failure condition during the decode process.
-     */    
-    protected abstract byte[] doDecoding(byte[] bytes) throws DecoderException;
-}
diff -Nru old\org\apache\commons\codec\net\URLCodec.java new\org\apache\commons\codec\net\URLCodec.java
--- old\org\apache\commons\codec\net\URLCodec.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\URLCodec.java	Thu Jan 01 01:00:00 1970
@@ -1,361 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import java.io.ByteArrayOutputStream;
-import java.io.UnsupportedEncodingException;
-import java.util.BitSet;
-
-import org.apache.commons.codec.BinaryDecoder;
-import org.apache.commons.codec.BinaryEncoder;
-import org.apache.commons.codec.DecoderException;
-import org.apache.commons.codec.EncoderException;
-import org.apache.commons.codec.CharEncoding;
-import org.apache.commons.codec.StringDecoder;
-import org.apache.commons.codec.StringEncoder;
-import org.apache.commons.codec.binary.StringUtils;
-
-/**
- * <p>Implements the 'www-form-urlencoded' encoding scheme, 
- * also misleadingly known as URL encoding.</p>
- *  
- * <p>For more detailed information please refer to 
- * <a href="http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1">
- * Chapter 17.13.4 'Form content types'</a> of the 
- * <a href="http://www.w3.org/TR/html4/">HTML 4.01 Specification<a></p>
- * 
- * <p> 
- * This codec is meant to be a replacement for standard Java classes
- * {@link java.net.URLEncoder} and {@link java.net.URLDecoder} 
- * on older Java platforms, as these classes in Java versions below 
- * 1.4 rely on the platform's default charset encoding.
- * </p>
- * 
- * @author Apache Software Foundation
- * @since 1.2
- * @version $Id: URLCodec.java 798416 2009-07-28 06:35:58Z ggregory $
- */
-public class URLCodec implements BinaryEncoder, BinaryDecoder, StringEncoder, StringDecoder {
-    
-    /**
-     * Radix used in encoding and decoding.
-     */
-    static final int RADIX = 16;
-    
-    /**
-     * The default charset used for string decoding and encoding. Consider this field final. The next major release may
-     * break compatibility and make this field be final.
-     */
-    protected String charset;
-    
-    /**
-     * Consider this field final. The next major release may break compatibility and make this field be final.
-     */
-    protected static byte ESCAPE_CHAR = '%';
-    /**
-     * BitSet of www-form-url safe characters.
-     */
-    protected static final BitSet WWW_FORM_URL = new BitSet(256);
-    
-    // Static initializer for www_form_url
-    static {
-        // alpha characters
-        for (int i = 'a'; i <= 'z'; i++) {
-            WWW_FORM_URL.set(i);
-        }
-        for (int i = 'A'; i <= 'Z'; i++) {
-            WWW_FORM_URL.set(i);
-        }
-        // numeric characters
-        for (int i = '0'; i <= '9'; i++) {
-            WWW_FORM_URL.set(i);
-        }
-        // special chars
-        WWW_FORM_URL.set('-');
-        WWW_FORM_URL.set('_');
-        WWW_FORM_URL.set('.');
-        WWW_FORM_URL.set('*');
-        // blank to be replaced with +
-        WWW_FORM_URL.set(' ');
-    }
-
-
-    /**
-     * Default constructor.
-     */
-    public URLCodec() {
-        this(CharEncoding.UTF_8);
-    }
-
-    /**
-     * Constructor which allows for the selection of a default charset
-     * 
-     * @param charset the default string charset to use.
-     */
-    public URLCodec(String charset) {
-        super();
-        this.charset = charset;
-    }
-
-    /**
-     * Encodes an array of bytes into an array of URL safe 7-bit characters. Unsafe characters are escaped.
-     * 
-     * @param urlsafe
-     *            bitset of characters deemed URL safe
-     * @param bytes
-     *            array of bytes to convert to URL safe characters
-     * @return array of bytes containing URL safe characters
-     */
-    public static final byte[] encodeUrl(BitSet urlsafe, byte[] bytes) {
-        if (bytes == null) {
-            return null;
-        }
-        if (urlsafe == null) {
-            urlsafe = WWW_FORM_URL;
-        }
-
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        for (int i = 0; i < bytes.length; i++) {
-            int b = bytes[i];
-            if (b < 0) {
-                b = 256 + b;
-            }
-            if (urlsafe.get(b)) {
-                if (b == ' ') {
-                    b = '+';
-                }
-                buffer.write(b);
-            } else {
-                buffer.write(ESCAPE_CHAR);
-                char hex1 = Character.toUpperCase(Character.forDigit((b >> 4) & 0xF, RADIX));
-                char hex2 = Character.toUpperCase(Character.forDigit(b & 0xF, RADIX));
-                buffer.write(hex1);
-                buffer.write(hex2);
-            }
-        }
-        return buffer.toByteArray();
-    }
-
-    /**
-     * Decodes an array of URL safe 7-bit characters into an array of 
-     * original bytes. Escaped characters are converted back to their 
-     * original representation.
-     *
-     * @param bytes array of URL safe characters
-     * @return array of original bytes 
-     * @throws DecoderException Thrown if URL decoding is unsuccessful
-     */
-    public static final byte[] decodeUrl(byte[] bytes) throws DecoderException {
-        if (bytes == null) {
-            return null;
-        }
-        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
-        for (int i = 0; i < bytes.length; i++) {
-            int b = bytes[i];
-            if (b == '+') {
-                buffer.write(' ');
-            } else if (b == ESCAPE_CHAR) {
-                try {
-                    int u = Utils.digit16(bytes[++i]);
-                    int l = Utils.digit16(bytes[++i]);
-                    buffer.write((char) ((u << 4) + l));
-                } catch (ArrayIndexOutOfBoundsException e) {
-                    throw new DecoderException("Invalid URL encoding: ", e);
-                }
-            } else {
-                buffer.write(b);
-            }
-        }
-        return buffer.toByteArray();
-    }
-
-    /**
-     * Encodes an array of bytes into an array of URL safe 7-bit 
-     * characters. Unsafe characters are escaped.
-     *
-     * @param bytes array of bytes to convert to URL safe characters
-     * @return array of bytes containing URL safe characters
-     */
-    public byte[] encode(byte[] bytes) {
-        return encodeUrl(WWW_FORM_URL, bytes);
-    }
-
-
-    /**
-     * Decodes an array of URL safe 7-bit characters into an array of 
-     * original bytes. Escaped characters are converted back to their 
-     * original representation.
-     *
-     * @param bytes array of URL safe characters
-     * @return array of original bytes 
-     * @throws DecoderException Thrown if URL decoding is unsuccessful
-     */
-    public byte[] decode(byte[] bytes) throws DecoderException {
-        return decodeUrl(bytes);
-    }
-
-    /**
-     * Encodes a string into its URL safe form using the specified string charset. Unsafe characters are escaped.
-     * 
-     * @param pString
-     *            string to convert to a URL safe form
-     * @param charset
-     *            the charset for pString
-     * @return URL safe string
-     * @throws UnsupportedEncodingException
-     *             Thrown if charset is not supported
-     */
-    public String encode(String pString, String charset) throws UnsupportedEncodingException {
-        if (pString == null) {
-            return null;
-        }
-        return StringUtils.newStringUsAscii(encode(pString.getBytes(charset)));
-    }
-
-    /**
-     * Encodes a string into its URL safe form using the default string 
-     * charset. Unsafe characters are escaped.
-     *
-     * @param pString string to convert to a URL safe form
-     * @return URL safe string
-     * @throws EncoderException Thrown if URL encoding is unsuccessful
-     * 
-     * @see #getDefaultCharset()
-     */
-    public String encode(String pString) throws EncoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return encode(pString, getDefaultCharset());
-        } catch (UnsupportedEncodingException e) {
-            throw new EncoderException(e.getMessage(), e);
-        }
-    }
-
-
-    /**
-     * Decodes a URL safe string into its original form using the 
-     * specified encoding. Escaped characters are converted back 
-     * to their original representation.
-     *
-     * @param pString URL safe string to convert into its original form
-     * @param charset the original string charset
-     * @return original string 
-     * @throws DecoderException Thrown if URL decoding is unsuccessful
-     * @throws UnsupportedEncodingException Thrown if charset is not
-     *                                      supported 
-     */
-    public String decode(String pString, String charset) throws DecoderException, UnsupportedEncodingException {
-        if (pString == null) {
-            return null;
-        }
-        return new String(decode(StringUtils.getBytesUsAscii(pString)), charset);
-    }
-
-    /**
-     * Decodes a URL safe string into its original form using the default
-     * string charset. Escaped characters are converted back to their 
-     * original representation.
-     *
-     * @param pString URL safe string to convert into its original form
-     * @return original string 
-     * @throws DecoderException Thrown if URL decoding is unsuccessful
-     * 
-     * @see #getDefaultCharset()
-     */
-    public String decode(String pString) throws DecoderException {
-        if (pString == null) {
-            return null;
-        }
-        try {
-            return decode(pString, getDefaultCharset());
-        } catch (UnsupportedEncodingException e) {
-            throw new DecoderException(e.getMessage(), e);
-        }
-    }
-
-    /**
-     * Encodes an object into its URL safe form. Unsafe characters are 
-     * escaped.
-     *
-     * @param pObject string to convert to a URL safe form
-     * @return URL safe object
-     * @throws EncoderException Thrown if URL encoding is not 
-     *                          applicable to objects of this type or
-     *                          if encoding is unsuccessful
-     */
-    public Object encode(Object pObject) throws EncoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof byte[]) {
-            return encode((byte[])pObject);
-        } else if (pObject instanceof String) {
-            return encode((String)pObject);
-        } else {
-            throw new EncoderException("Objects of type " +
-                pObject.getClass().getName() + " cannot be URL encoded"); 
-              
-        }
-    }
-
-    /**
-     * Decodes a URL safe object into its original form. Escaped characters are converted back to their original
-     * representation.
-     * 
-     * @param pObject
-     *                  URL safe object to convert into its original form
-     * @return original object
-     * @throws DecoderException
-     *                  Thrown if the argument is not a <code>String</code> or <code>byte[]</code>. Thrown if a failure condition is
-     *                  encountered during the decode process.
-     */
-    public Object decode(Object pObject) throws DecoderException {
-        if (pObject == null) {
-            return null;
-        } else if (pObject instanceof byte[]) {
-            return decode((byte[]) pObject);
-        } else if (pObject instanceof String) {
-            return decode((String) pObject);
-        } else {
-            throw new DecoderException("Objects of type " + pObject.getClass().getName() + " cannot be URL decoded");
-
-        }
-    }
-
-    /**
-     * The <code>String</code> encoding used for decoding and encoding.
-     * 
-     * @return Returns the encoding.
-     * 
-     * @deprecated use #getDefaultCharset()
-     */
-    public String getEncoding() {
-        return this.charset;
-    }
-
-    /**
-     * The default charset used for string decoding and encoding.
-     *
-     * @return the default string charset.
-     */
-    public String getDefaultCharset() {
-        return this.charset;
-    }
-
-}
diff -Nru old\org\apache\commons\codec\net\Utils.java new\org\apache\commons\codec\net\Utils.java
--- old\org\apache\commons\codec\net\Utils.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\net\Utils.java	Thu Jan 01 01:00:00 1970
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec.net;
-
-import org.apache.commons.codec.DecoderException;
-
-/**
- * Utility methods for this package.
- * 
- * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>
- * @version $Id: Utils.java 798611 2009-07-28 17:10:44Z ggregory $
- * @since 1.4
- */
-class Utils {
-
-    /**
-     * Returns the numeric value of the character <code>b</code> in radix 16.
-     * 
-     * @param b
-     *            The byte to be converted.
-     * @return The numeric value represented by the character in radix 16.
-     * 
-     * @throws DecoderException
-     *             Thrown when the byte is not valid per {@link Character#digit(char,int)}
-     */
-    static int digit16(byte b) throws DecoderException {
-        int i = Character.digit((char) b, 16);
-        if (i == -1) {
-            throw new DecoderException("Invalid URL encoding: not a valid digit (radix " + URLCodec.RADIX + "): " + b);
-        }
-        return i;
-    }
-
-}
diff -Nru old\org\apache\commons\codec\overview.html new\org\apache\commons\codec\overview.html
--- old\org\apache\commons\codec\overview.html	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\overview.html	Thu Jan 01 01:00:00 1970
@@ -1,29 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<!-- $Id: overview.html 561548 2007-07-31 21:16:26Z mbenson $ -->
-<html>
-<body>
-<p>
-This document is the API specification for the Apache Commons Codec Library, version 1.3.
-</p>
-<p>
-This library requires a JRE version of 1.2.2 or greater.
-The hypertext links originating from this document point to Sun's version 1.3 API as the 1.2.2 API documentation 
-is no longer on-line.
-</p>
-</body>
-</html>
diff -Nru old\org\apache\commons\codec\package.html new\org\apache\commons\codec\package.html
--- old\org\apache\commons\codec\package.html	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\package.html	Thu Jan 01 01:00:00 1970
@@ -1,100 +0,0 @@
-<!--
-Licensed to the Apache Software Foundation (ASF) under one or more
-contributor license agreements.  See the NOTICE file distributed with
-this work for additional information regarding copyright ownership.
-The ASF licenses this file to You under the Apache License, Version 2.0
-(the "License"); you may not use this file except in compliance with
-the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
-Unless required by applicable law or agreed to in writing, software
-distributed under the License is distributed on an "AS IS" BASIS,
-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-See the License for the specific language governing permissions and
-limitations under the License.
--->
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
-<html>
-  <head>
-  </head>
-  <body>
-    <p>A small set of interfaces used by
-    the various implementations in the sub-packages.</p>
-
-    <p>Definitive implementations of commonly used encoders and decoders.</p>
-
-    <p>Codec is currently comprised of a modest set of utilities and a
-    simple framework for String encoding and decoding in three categories:
-    Binary Encoders, Language Encoders, and Network Encoders. </p>
-
-    <h4><a name="Common Encoders">Binary Encoders</a></h4>
-
-    <table border="1" width="100%" cellspacing="2" cellpadding="3">
-  	  <tbody>
-        <tr>
-          <td> 
-            <a href="binary/Base64.html">
-              org.apache.commons.codec.binary.Base64</a>
-          </td>
-          <td> 
-            Provides Base64 content-transfer-encoding as defined in 
-            <a href="http://www.ietf.org/rfc/rfc2045.txt"> RFC 2045</a> 
-          </td>
-          <td>Production</td>
-        </tr>
-        <tr>
-          <td>
-           <a href="binary/Hex.html">
-             org.apache.commons.codec.binary.Hex</a>
-          </td>
-          <td> 
-            Converts an array of bytes into an array of characters
-            representing the hexidecimal values of each byte in order 
-          </td>
-          <td>Production</td>
-        </tr>
-      </tbody>
-    </table>
-    <h4> 
-      <a name="Language Encoders">Language Encoders</a> 
-    </h4>
-    <p> 
-      Codec contains a number of commonly used language and phonetic
-      encoders
-    </p>
-    <table border="1" width="100%" cellspacing="2" cellpadding="3">
-      <tbody>
-        <tr>
-          <td> 
-            <a href="#">org.apache.commons.codec.language.Soundex</a>
-          </td>
-          <td>Implementation of the Soundex algorithm.</td>
-          <td>Production</td>
-        </tr>
-        <tr>
-          <td> 
-            <a href="#">org.apache.commons.codec.language.Metaphone</a>
-          </td>
-          <td>Implementation of the Metaphone algorithm.</td>
-          <td>Production</td>
-        </tr>
-      </tbody>
-    </table>
-    <h4><a name="Network_Encoders">Network Encoders</a></h4>
-    <h4> </h4>
-    <p> Codec contains network related encoders </p>
-    <table border="1" width="100%" cellspacing="2" cellpadding="3">
-      <tbody>
-        <tr>
-          <td> 
-            <a href="#">org.apache.commons.codec.net.URLCodec</a>
-          </td>
-          <td>Implements the 'www-form-urlencoded' encoding scheme.</td>
-          <td>Production</td>
-        </tr>
-      </tbody>
-    </table>
-    <br>
-  </body>
-</html>
diff -Nru old\org\apache\commons\codec\StringDecoder.java new\org\apache\commons\codec\StringDecoder.java
--- old\org\apache\commons\codec\StringDecoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\StringDecoder.java	Thu Jan 01 01:00:00 1970
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * Decodes a String into a String. 
- *
- * @author Apache Software Foundation
- * @version $Id: StringDecoder.java 634915 2008-03-08 09:30:25Z bayard $
- */
-public interface StringDecoder extends Decoder {
-    
-    /**
-     * Decodes a String and returns a String.
-     * 
-     * @param pString a String to encode
-     * 
-     * @return the encoded String
-     * 
-     * @throws DecoderException thrown if there is
-     *  an error conidition during the Encoding process.
-     */
-    String decode(String pString) throws DecoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\StringEncoder.java new\org\apache\commons\codec\StringEncoder.java
--- old\org\apache\commons\codec\StringEncoder.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\StringEncoder.java	Thu Jan 01 01:00:00 1970
@@ -1,40 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-/**
- * Encodes a String into a String. 
- *
- * @author Apache Software Foundation
- * @version $Id: StringEncoder.java 651573 2008-04-25 11:11:21Z niallp $
- */
-public interface StringEncoder extends Encoder {
-    
-    /**
-     * Encodes a String and returns a String.
-     * 
-     * @param pString a String to encode
-     * 
-     * @return the encoded String
-     * 
-     * @throws EncoderException thrown if there is
-     *  an error conidition during the Encoding process.
-     */
-    String encode(String pString) throws EncoderException;
-}  
-
diff -Nru old\org\apache\commons\codec\StringEncoderComparator.java new\org\apache\commons\codec\StringEncoderComparator.java
--- old\org\apache\commons\codec\StringEncoderComparator.java	Thu Aug 06 17:40:30 2009
+++ new\org\apache\commons\codec\StringEncoderComparator.java	Thu Jan 01 01:00:00 1970
@@ -1,86 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.codec;
-
-import java.util.Comparator;
-
-/**
- * Strings are comparable, and this comparator allows 
- * you to configure it with an instance of a class
- * which implements StringEncoder.  This comparator
- * is used to sort Strings by an encoding scheme such
- * as Soundex, Metaphone, etc.  This class can come in
- * handy if one need to sort Strings by an encoded
- * form of a name such as Soundex.
- *
- * @author Apache Software Foundation
- * @version $Id: StringEncoderComparator.java 793391 2009-07-12 18:38:08Z ggregory $
- */
-public class StringEncoderComparator implements Comparator {
-
-    /**
-     * Internal encoder instance.
-     */
-    private final StringEncoder stringEncoder;
-
-    /**
-     * Constructs a new instance.
-     * @deprecated as creating without a StringEncoder will lead to a 
-     *             broken NullPointerException creating comparator.
-     */
-    public StringEncoderComparator() {
-        this.stringEncoder = null;   // Trying to use this will cause things to break
-    }
-
-    /**
-     * Constructs a new instance with the given algorithm.
-     * @param stringEncoder the StringEncoder used for comparisons.
-     */
-    public StringEncoderComparator(StringEncoder stringEncoder) {
-        this.stringEncoder = stringEncoder;
-    }
-
-    /**
-     * Compares two strings based not on the strings 
-     * themselves, but on an encoding of the two 
-     * strings using the StringEncoder this Comparator
-     * was created with.
-     * 
-     * If an {@link EncoderException} is encountered, return <code>0</code>.
-     * 
-     * @param o1 the object to compare
-     * @param o2 the object to compare to
-     * @return the Comparable.compareTo() return code or 0 if an encoding error was caught.
-     * @see Comparable
-     */
-    public int compare(Object o1, Object o2) {
-
-        int compareCode = 0;
-
-        try {
-            Comparable s1 = (Comparable) this.stringEncoder.encode(o1);
-            Comparable s2 = (Comparable) this.stringEncoder.encode(o2);
-            compareCode = s1.compareTo(s2);
-        } 
-        catch (EncoderException ee) {
-            compareCode = 0;
-        }
-        return compareCode;
-    }
-
-}
